<!DOCTYPE HTML>
<div>
<script type="text/javascript" async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</div>

<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>MATH1120 Sage Playground</title>
    <script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
    <script>
    // Make the div with id 'mycell' a Sage cell
    sagecell.makeSagecell({inputLocation:  '#mycell',
                           template:       sagecell.templates.minimal,
                           evalButtonText: 'Activate'});
    // Make *any* div with class 'compute' a Sage cell
    sagecell.makeSagecell({inputLocation: 'div.compute',
                           evalButtonText: 'Evaluate'});
    </script>
  </head>
  <body>


  <h1>Sage Playground for MATH1120 - 2021</h1>

  SageMath is a powerful open source mathematics package used by actual researchers.<br><br>

  <b>
  Note: You don't need to know anything about Sage to play with the examples on this page:
  just click "evaluate" underneath a cell and see what happens. Enjoy!
  </b>
  <br><br>

  You can download SageMath <a href="https://www.sagemath.org/">here</a>.<br>

  You can also just run Sage commands online, on this page or on the
  <a href="https://sagecell.sagemath.org/">Sage Cell Server</a>.<br>

  Sage <a href="https://doc.sagemath.org/html/en/tutorial/index.html">Tutorials</a> and documentation are
  <a href="https://doc.sagemath.org/">here</a>.<br>

<hr>
<h1>Contents</h1>
<ul>
  <li><a href="#CA1">Calculus I : Maclaurin series</a></li>
  <li><a href="#CA2">Calculus II: Taylor series</a></li>
  <li><a href="#CA3">Calculus III : Functions of Several Variables</a></li>
  <li><a href="#CA4">Calculus IV : Partial Derivatives</a></li>
  <li><a href="#CA5">Calculus V : Tangent Planes </a></li>
  <li><a href="#CA6">Calculus VI : Directional derivative and gradient vectors </a></li>
  <li><a href="#CA7">Calculus VII: Global Minima and Maxima </a></li>
  <li><a href="#CA8">Calculus VIII: Chain Rules </a></li>
  <li><a href="#DE1">Differential Equations I: Direction Fields and Euler's Method </a></li>
  <li><a href="#DE2">Differential Equations II: Separable DEs</a></li>
  <li><a href="#SIR">The SIR model of epidemics</a></li>
  <li><a href="#DE6">Differential Equations VI: Applications</a></li>
  <li><a href="#LA1">Linear Algebra I: Systems of Linear Equations</a></li>
  <li><a href="#LA3">Linear Algebra III: Matrices and Linear Transformations</a></li>
  <li><a href="#LA4">Linear Algebra IV: Square matrices</a></li>
  <li><a href="#LA5">Linear Algebra V: Eigenvectors and Eigenvalues</a></li>
  <li><a href="#LA6">Linear Algebra VI: Applications of Eigenvalues and Eigenvectors</a></li>
</ul>
<hr>

<h2 id="CA1">Calculus I : Maclaurin series</h2>

Compute partial sums for the infinite series
\[
\sum_{k=0}\frac{1}{2^k} = 1 + \frac{1}{2} + \frac{1}{4} + \frac{1}{8} + \cdots
\]

<div class="compute"><script type="text/x-sage">
s = 1
for i in range(1,20):
    s = s+2^(-i)
    t='1 + '+'+'.join([r'\frac{1}{2^{'+str(j)+r'}}' for j in range(1,i+1)])+'= '+latex(s)+' = '+latex(n(s))
    show(t)
</script></div>

<br>
<br>

Plot terms of the Maclaurin series for \(\sin(x)\):
\[
\sin(x) = x - \frac{1}{3!}x^3 + \frac{1}{5!}x^5 - \frac{1}{7!}x^7 + \cdots
\]
<div class="compute"><script type="text/x-sage">
x   = var('x')
x0  = 0
f   = sin(x)
p   = plot(f, -2*pi, 2*pi, thickness=2)
dot = point((x0, f(x=x0)), pointsize=80, rgbcolor=(1, 0, 0))

@interact
def _(order=slider([1 .. 12])):
    ft = f.taylor(x, x0, order)
    pt = plot(ft, -2*pi, 2*pi, color='green', thickness=2)
    pretty_print(html(r'$f(x)\;=\;%s$' % latex(f)))
    pretty_print(html(r'$T_{%s}f(x)\;=\;%s+\mathcal{O}(x^{%s})$' % (order, latex(ft), order+1)))
    show(dot + p + pt, ymin=-1, ymax=1)
</script></div>
<br>

<h2 id="CA2">Calculus II: Taylor series</h2>

Plot Taylor polynomials for various functions:

<div class="compute"><script type="text/x-sage">
x   = var('x')

@interact
def _(f = input_box(default='sin(x)', label='f(x)='),
      x0=input_box(default=pi/4, label='centre'),
      order=slider([1 .. 12])):
    p   = plot(f, -2*pi, 2*pi, thickness=2, legend_label='f(x)')
    dot = point((x0, f(x=x0)), pointsize=80, rgbcolor=(1, 0, 0))
    ft = f.taylor(x, x0, order)
    pt = plot(ft, -2*pi, 2*pi, color='green', thickness=2, legend_label=r'T_'+str(order)+'f(x)')
    pretty_print(html(r'$f(x)\;=\;%s$' % latex(f)))
    pretty_print(html(r'$T_{%s}f(x)\;=\;%s+\mathcal{O}(x^{%s})$' % (order, latex(ft), order+1)))
    show(dot + p + pt, ymin=-1, ymax=1)
</script></div>
<br>

Some examples I showed in class:
<br><br>
\[
f(x) = \frac{1}{1-x} = 1 + x + x^2 + x^3 + \cdots
\]
This Maclaurin series converges for \( |x|< 1 \).
Even though the function makes sense for other values of \(x\neq 1\),
the series doesn't converge there.

<div class="compute"><script type="text/x-sage">
N = 5
ft = sum(x^k for k in range(N+1))
show('Blue: y = '+latex(ft))
show(r'Green: y = \frac{1}{1-x}'+latex(''))
plot([ft, 1/(1-x)], (x,-3,3), ymax=5, ymin=-5, thickness=2)
</script></div>
<br>

The Taylor series for \(f(x)=\ln(x)\) centered at \(x=e\):
\[
\ln(x) = 1 + \sum_{k=1}^\infty (-1)^{k-1}\frac{1}{k}e^k (x-e)^k, \quad |x-e|< e.
\]
Note that the series only converges for \( x\in (0,2e) \).

<div class="compute"><script type="text/x-sage">
N = 5
ft = 1+sum(1/k*exp(-k)*(x-exp(1))^k*(-1)^(k-1) for k in range(1,N+1) )
show('T_{'+str(N)+'}f(x) = '+latex(ft))
show(plot([log(x), ft], (x,0,10), ymax=10, ymin=-5, legend_label = ['ln(x)','T_'+str(N)+' ln(x)'], thickness=2)+
     plot(line([(2*exp(1),-5),(2*exp(1),10)],color='gray'))+
     text('x=2e',(2*exp(1)+0.5,-3), color='gray'))
</script></div>


<h2 id="CA3">Calculus III : Functions of Several Variables</h2>


<b>3D plots of functions we saw in class:</b><br><br>

\(f(x,y)=xy\):<br>
<div class="compute"><script type="text/x-sage">
x,y=var('x','y')
f=x*y
Mx=1
My=1
plot3d(f,(x,-Mx,Mx),(y,-My,My),axes=true)
</script></div>

<br>
The sombrero:
\(f(x,y)=1-\sqrt{x^2+y^2}e^{-(x^2+y^2)}\):<br>
<div class="compute"><script type="text/x-sage">
x,y=var('x','y')
f=1-sqrt(x^2+y^2)*exp(-x^2-y^2)
Mx=1
My=1
plot3d(f,(x,-Mx,Mx),(y,-My,My))
</script></div>

<br>
Now we plot both the 3D graph and a contour plot:<br>
\( f(x,y)=\sin(y)e^{x/5}\)<br>
<div class="compute"><script type="text/x-sage">
x,y=var('x','y')
f=sin(y)*exp(x/5)
Mx=10
My=10
show(plot3d(f,(x,-Mx,Mx),(y,-My,My)),plot_points=500,adaptive=true)
show(contour_plot(f,(x,-Mx,Mx),(y,-My,My),colorbar=True,labels=True,contours=30,plot_points=500))
</script></div>
<br>

Now for a surface of revolution. If you rotate the graph of \(z=f(x), \; x\geq 0,\) about the
\(z\)-axis, you get a surface with equation
\[
z = f\left(\sqrt{x^2+y^2}\right).
\]
For example:
<div class="compute"><script type="text/x-sage">
x,y = var('x y')
f = sin(x)
M=4

F = f(x=sqrt(x^2+y^2))
show(plot(f,(x,0,M),title='z='+str(f)))
show('z='+latex(F))
show(plot3d(F,(x,-M,M),(y,-M,M)))
</script></div>
<br>

Here we plot some level surfaces of a function of 3 variables:
$$f(x,y,z) = x^2 + 3y^2 + 5z^3 = k$$
for \(k=-5,0,5\):
<div class="compute"><script type="text/x-sage">
x,y,z = var('x y z')
f = x^2 + 3*y^2 + 5*z^3
M = 2
Ks = [0, 5, -5]
sum([implicit_plot3d(f == k, (x,-M,M), (y,-M,M), (z,-M,M), plot_points=100, opacity=0.6) for k in Ks])
</script></div>
<br>

<h2 id="CA4">Calculus IV : Partial Derivatives</h2>

Consider the a function of two variables, for example
\[
f(x,y) = x^2\sin(x+5y).
\]
The following plots the graph of \(z=f(x,y)\), together with the vertical planes
defined by \(y=y_0\) (in orange) and \(x=x_0\) (in red), and arrows representing
the slope of the surface inside these planes. These slopes are given by the
partial derivatives \(f_x(x,y)\) (where \(y=y_0\) is kept constant, in the orange plane)
and  \(f_y(x,y)\) (where \(x=x_0\) is kept constant, in the red plane).<br>
<div class="compute"><script type="text/x-sage">
x,y,z = var('x y z')
f = x^2*sin(x+5*y)
# f = 1-x^2 - y^2
M = 1
h = 0.5

fx = diff(f,x)
fy = diff(f,y)

@interact
def _(
    x0 = slider(-M, M, default=0, step_size=0.05),
    y0 = slider(-M, M, default=0, step_size=0.05),
        show_x_arrow = true,
        show_y_arrow = true,
        show_x_plane = true,
        show_y_plane = true,
        show_tangent_plane = false,
    auto_update=False
    ):
    z0 = f(x=x0,y=y0)
    show('f(x,y) = '+latex(f))
    p = plot3d(f,(x,-M,M),(y,-M,M))+sphere((x0,y0,z0),0.05,color='black')
    if show_x_arrow:
        p = p+arrow3d((x0,y0,z0),(x0+h,y0,z0+fx(x=x0,y=y0)*h),color='black')
        show(r'f_x(x,y) = '+latex(fx)+r';\qquad f_x('+str(n(x0,3))+','+str(n(y0,3))+') = '+latex(n(fx(x=x0,y=y0))))
    if show_x_plane:
        p = p+implicit_plot3d(y==y0, (x,-M,M), (y,-M,M), (z,-M,M), color='orange', opacity=0.9)
    if show_y_arrow:
        p = p+arrow3d((x0,y0,z0),(x0,y0+h,z0+fy(x=x0,y=y0)*h),color='gray')
        show(r'f_y(x,y) = '+latex(fy)+r';\qquad f_y('+str(n(x0,3))+','+str(n(y0,3))+') = '+latex(n(fy(x=x0,y=y0))))
    if show_y_plane:
        p = p+implicit_plot3d(x==x0, (x,-M,M), (y,-M,M), (z,-M,M), color='red', opacity=0.9)
    if show_tangent_plane:
        p = p+plot3d(z0+fx(x=x0,y=y0)*(x-x0)+fy(x=x0,y=y0)*(y-y0), (x,x0-h,x0+h), (y,y0-h,y0+h), color='green', opacity=0.5)
    show(p)
</script></div>
<br>


<h2 id="CA5">Calculus V : Tangent Planes</h2>

You may have noticed that the 3d plot above has an option for showing the tangent plane...<br><br>

Here are some more examples.<br>

<div class="compute"><script type="text/x-sage">
x,y=var('x','y')

#f = 5-(x^2+y^2)/2
f = x*y

Mx=2
My=2
fx=diff(f,x)
fy=diff(f,y)
show('f(x,y)='+latex(f(x=x,y=y)))
show(r'f_x=\frac{\partial f}{\partial x} = '+latex(fx))
show(r'f_y=\frac{\partial f}{\partial y} = '+latex(fy))

@interact
def _(x0=slider(-Mx,Mx,step_size=0.1,default=0),y0=slider(-My,My,step_size=0.1,default=0),auto_update=False):
    L = f(x=x0,y=y0)+fx(x=x0,y=y0)*(x-x0)+fy(x=x0,y=y0)*(y-y0)
    show('(x_0,y_0)='+latex((x0,y0)))
    show('(f_x('+latex(x0)+'),f_y('+latex(y0)+'))='+latex((fx(x=x0,y=y0),fy(x=x0,y=y0))))
    show('L(x,y)='+latex(L(x=x,y=y)))
    show(plot3d(f,(x,-Mx,Mx),(y,-My,My),color='blue')+plot3d(L,(x,-Mx,Mx),(y,-My,My),color='red'))
</script></div>


<br>
Tangent plane to an implicitly defined surface:<br>
The tangent plane to \( z-yz^3=x+2\) at the point \((x_0,y_0,z_0)=(2,0,3)\): <br>
<div class="compute"><script type="text/x-sage">
x,y,z=var('x','y','z')
implicit_plot3d(z-y*z^3==x+2,(x,-4,4),(y,-4,4),(z,-4,4),color='blue')+\
implicit_plot3d(z==x+27*y+2,(x,-4,4),(y,-4,4),(z,-4,4),color='red')
</script></div>

<h2 id="CA6">Calculus VI : Directional derivative and gradient vectors</h2>

In the following plot, we have the function
\[
f(x,y) = \cos(x)\sin(y),
\]
and we pick a location \((x,y)\) and a unit vector \(\hat{u}\) (red arrow) in the direction
given by some angle. <br>
The gradient vector \(\nabla f(x,y)\) at that location is the orange arrow,
which points in the direction of steepest ascent on the surface \(z=f(x,y)\), and the
tangent line to the surface \(z=f(x,y)\) is plotted in green. The gradient of that tangent
line is the directional derivative.<br><br>

<div class="compute"><script type="text/x-sage">
var('x,y,t,z')
f(x,y)=sin(x)*cos(y)

pif = float(pi)

line_thickness=3
surface_color='blue'
plane_color='purple'
line_color='red'
tangent_color='green'
gradient_color='orange'

@interact
def myfun(location=input_grid(1, 2, default=[0,0], label = "Location (x,y)", width=2),
          angle=slider(0, 2*pif, label = "Angle", step_size=0.01),
          auto_update=false,
          show_surface=("Show surface", True),
          show_plane=("Show plane", True)):

    location3d = vector(location[0]+[f(x=location[0][0],y=location[0][1])])
    location = location3d[0:2]
    direction3d = vector(RDF, [cos(angle), sin(angle), 0])
    direction=direction3d[0:2]
    cos_angle = math.cos(angle)
    sin_angle = math.sin(angle)
    df = f.gradient()
    direction_vector=line3d([location3d, location3d+direction3d], arrow_head=True, rgbcolor=line_color, thickness=line_thickness)
    curve_point = (location+t*direction).list()
    curve = parametric_plot(curve_point+[f(*curve_point)], (t,-3,3),color=line_color,thickness=line_thickness)
    plane = parametric_plot((cos_angle*x+location[0],sin_angle*x+location[1],t), (x, -3,3), (t,-3,3),opacity=0.8, color=plane_color)
    pt = point3d(location3d.list(),color='green', size=10)

    tangent_line = parametric_plot((location[0]+t*cos_angle, location[1]+t*sin_angle, f(*location)+t*df(*location)*(direction)), (t, -3,3), thickness=5, color=tangent_color)
    picture3d = direction_vector+curve+pt+tangent_line
    if show_plane:
        picture3d += plane

    picture2d = contour_plot(f(x,y), (x,-3,3),(y,-3,3), plot_points=100)
    picture2d += arrow(location.list(), (location+direction).list(), color='red')
    picture2d += point(location.list(),color='black',pointsize=40)
    if show_surface:
        picture3d += plot3d(f, (x,-3,3),(y,-3,3),opacity=0.7)

    dff = df(location[0], location[1])
    dff3d = vector(RDF,dff.list()+[0])
    picture3d += line3d([location3d, location3d+dff3d], arrow_head=True, rgbcolor=gradient_color, thickness=line_thickness)
    picture2d += arrow(location.list(), (location+dff).list(), rgbcolor=gradient_color, width=line_thickness)

    show('f(x,y) = '+latex(f(x,y)))
    show(r'\nabla f(x,y) = \langle'+latex(df(x,y)[0])+','+latex(df(x,y)[1])+r'\rangle')
    show(r'\nabla f'+latex(vector(location))+r' = \langle'+latex(n(dff[0]))+','+latex(n(dff[1]))+r'\rangle')
    show(r'\hat{u} = \langle'+latex(n(direction[0]))+','+latex(n(direction[1]))+r'\rangle')
    show(r'D_{\hat{u}}\,f'+latex(vector(location))+' = '+latex(n(dff[0]*direction[0]+dff[1]*direction[1])))

    show(picture3d,aspect=[1,1,1], axes=True)
    show(picture2d, aspect_ratio=1)
</script></div>

Here we plot the function
\[ f(x,y) = xy+y^2-x^3, \]
its level curves and the gradient vectors \(\nabla f\) (in red):<br><br>

<div class="compute"><script type="text/x-sage">
x,y=var('x','y')
M=1
f=x*y+y^2-x^3
#f=x*y
show('f(x,y)='+latex(f))
show(r'\nabla f(x,y) = '+latex(f.gradient()))
show(contour_plot(f,(x,-M,M),(y,-M,M),contours=30,fill=false)+\
     plot_vector_field(f.gradient(),(x,-M,M),(y,-M,M),color='red'))
show(plot3d(f,(x,-M,M),(y,-M,M)))
</script></div>
(You can uncomment the line <tt>f=x*y</tt> to plot \( f(x,y) = xy \),
or replace it with any function of your choice.)
<br><br>

For functions of three variables, the gradient vector is perpendicular to <thead>
  level surfaces of the function. We can use this to obtain an equation for
the tangent plane of a surface. <br><br>

For example, the "rugby ball" we did in class:

<div class="compute"><script type="text/x-sage">
x,y,z = var('x y z')
f = x^2 + 2*y^2 + 3*z^2
(x0,y0,z0) = (1,1,-1)
M = 2.5

df = f.gradient()
dff = df(x=x0,y=y0,z=z0)
du = dff.normalized()

surface = implicit_plot3d(f == f(x=x0,y=y0,z=z0), (x,-M,M), (y,-M,M), (z,-M,M), color='blue', opacity=0.9, aspectario=1)
Point = sphere((x0,y0,z0), 0.1, color='black')
normal_vector = arrow((x0,y0,z0),(x0+du[0],y0+du[1],z0+du[2]), color='red')
tangent_plane = implicit_plot3d(du[0]*(x-x0)+du[1]*(y-y0)+du[2]*(z-z0), (x,-M,M), (y,-M,M), (z,-M,M), color='green',
                                opacity=0.5)
show(latex(f==f(x=x0,y=y0,z=z0)))
show(surface+Point+normal_vector+tangent_plane)
</script></div>

Another example: we compute the tangent plane
to the surface \( xy+yz^2+xz^3 = 54 \) at the point \( (2,0,3) \). <br>
This surface is a level surface of the function
\( f(x,y,z) = xy+yz^2+xz^3 \).
The gradient vector is then a normal vector for the surface, and we have a point
on the surface, and this lets us determine an equation for the
tangent surface:
\[
L : f_x(2,0,3)(x-2) + f_y(2,0,3)(y-0) + f_z(2,0,3)(z-3) = 0.
\]


<div class="compute"><script type="text/x-sage">
x,y,z = var('x','y','z')

f=x*y+y*z^2+x*z^3
(x0,y0,z0) = (2,0,3)

M=5
fx=diff(f,x)
fy=diff(f,y)
fz=diff(f,z)

L = fx(x=x0,y=y0,z=z0)*(x-x0)+fy(x=x0,y=y0,z=z0)*(y-y0)+fz(x=x0,y=y0,z=z0)*(z-z0)

show("f(x,y,z)="+latex(f))
show(r"\nabla f(x,y,z) = "+latex(f.gradient()))
show(r"(x_0,y_0,z_0) = "+latex((x0,y0,z0)))
show(r"\text{Tangent plane: }"+latex(L)+" = 0")

show(
    implicit_plot3d(f==f(x=x0,y=y0,z=z0),(x,-M,M),(y,-M,M),(z,-M,M),plot_points=100)+\
    implicit_plot3d(L==0,(x,-M,M),(y,-M,M),(z,-M,M),plot_points=100,color='red')+\
    sphere((x0,y0,z0),0.1,color='black')
)
</script></div>


<h2 id="CA7">Calculus VII: Global Minima and Maxima</h2>

The critical points of the function \( f(x,y) = 2x^3+(x+1)y^2+5x^2 \):
<div class="compute"><script type="text/x-sage">
x,y = var('x','y')
f=2*x^3+(x+1)*y^2+5*x^2
show("f(x,y) = "+latex(f))
show(
    plot3d(f,(x,-2,1),(y,-3,3),plot_points=100,aspect_ratio=[1,1,0.2])+\
    sphere((0,0,f(x=0,y=0)),0.1,color='red')+\
    sphere((-5/3,0,f(x=-5/3,y=0)),0.1,color='red')+\
    sphere((-1,2,f(x=-1,y=2)),0.1,color='red')+\
    sphere((-1,-2,f(x=-1,y=-2)),0.1,color='red')
)
show(
    contour_plot(f,(x,-2,1),(y,-3,3),plot_points=100,contours=40,fill=false)+\
    circle((0,0),0.01,color='red')+\
    circle((-5/3,0),0.01,color='red')+\
    circle((-1,2),0.01,color='red')+\
    circle((-1,-2),0.01,color='red')
)
</script></div>

<br><br>
Another example:
The critical points of the function \( f(x,y) = 3x-x^3-2y^2+y^4 \):
<div class="compute"><script type="text/x-sage">
x,y=var('x y')
f=3*x-x^3-2*y^2+y^4
crits = [(1,0),(1,1),(1,-1),(-1,0),(-1,1),(-1,-1)]
M=2
show(
    plot3d(f,(x,-M,M),(y,-M,M),plot_points=100,aspect_ratio=[1,1,0.3],opacity=0.9)+\
    sum(sphere((P[0],P[1],f(x=P[0],y=P[1])),0.1,color='red') for P in crits)
)
show(
    contour_plot(f,(x,-M,M),(y,-M,M),plot_points=500,contours=40,fill=false)+\
    sum([circle(P,0.02,color='red') for P in crits])
)
</script></div>

<br><br>
Global maximum and minimum of \( f(x,y) = 2x^2+x+y^2-2 \) on the disc
\( D = \{ (x,y)\in\mathbb{R}^2 \;|\; x^2+y^2 \leq 4 \} \):
<div class="compute"><script type="text/x-sage">
r,t=var('r t')
parametric_plot3d((r*cos(t),r*sin(t),2*(r*cos(t))^2+r*cos(t)+(r*sin(t))^2-2),(t,0,2*pi),(r,0,2),
opacity=1,aspect_ratio=[1,1,0.3])+sphere((-1/4,0,-17/8),0.1,color='red')+sphere((2,0,8),0.1,color='red')+\
parametric_plot3d((r*cos(t),r*sin(t),0),(t,0,2*pi),(r,0,2),
opacity=0.6,color='green')</script></div>


<h2 ID="CA8">Calculus VIII: Chain Rules</h2>

The magic formula for implicit differentiation:
If \( f(x,y) = c \) defines \( y(x) \) implicitly as a function of \(x\), then
\[
\frac{dy}{dx} = -\frac{f_x}{f_y}.
\]
In the following plot, we have
\[
f(x,y) = x\cos y + y\cos x - x.
\]
You can choose the value of the constant \( c\) with the slider, and the plot shows
the curve \( f(x,y) = c \) in blue, and the slopes given by
\[
\frac{dy}{dx} = -\frac{y\sin x - \cos y + 1}{x\sin y - \cos x}
\]
as little grey line segments. The slope of each segment is given by evaluating
\(\frac{dy}{dx}\) at its \( (x,y)\)-position. Note that these slopes are tangential
to the curve, as they must be.<br><br>
You can also see the 3d plot of \( z = f(x,y) \) and a "water level" of \(z=c\), then
the shoreline represents the curve \( f(x,y) = c \). Finally, you can show the
gradient vectors \(\nabla f(x,y)\) (red arrows), which are of course perpendicular to
the level curves (and thus the grey slopes).<br>
<div class="compute"><script type="text/x-sage">
x,y = var('x y')
M = 5

f = x*cos(y)+y*cos(x)-x

fx = diff(f,x)
fy = diff(f,y)

show(r"\frac{dy}{dx} = "+latex(-fx/fy))

@interact
def _(c=slider(-5,5,step_size=0.1,default=0),
    auto_update=true,
    slopes = true,
    gradient = false,
    show3d = false):
    show(r"f(x,y) = "+latex(f)+r" = "+latex(c))
    P = implicit_plot(f==c,(x,-M,M),(y,-M,M))
    if slopes:
        P=P+plot_slope_field(-fx/fy,(x,-M,M),(y,-M,M),plot_points=30,color='gray')
    if gradient:
        P=P+plot_vector_field(f.gradient(),(x,-M,M),(y,-M,M),plot_points=30,color='red')
    show(P)
    if show3d:
        show(plot3d(f,(x,-M,M),(y,-M,M),aspect_ratio=[1,1,0.5], color='green')+plot3d(c,(x,-M,M),(y,-M,M),opacity=0.5,color='blue'))
</script></div>

<h2 id="DE1">Differential Equations I: Direction Fields and Euler's Method</h2>

Plot the firection field of \(\frac{dy}{dx} = f(x,y)\), as well as a particular solution:
<div class="compute"><script type="text/x-sage">
x,y = var('x,y')
from sage.ext.fast_eval import fast_float
@interact
def _(f=input_box(default=x-y),
      xrange=range_slider(-10,10,default=(-2,2)),
      yrange=range_slider(-10,10,default=(-2,2)),
      start_x=input_box(default=-2), start_y=input_box(default=0.5),
      #start_y = slider(-2,2,default=0,step_size=0.1),
      step_size=slider(0.01,0.2,step_size=0.01), steps=(600,(0, 1400)), auto_update=false ):
    (xmin,xmax)=xrange
    (ymin,ymax)=yrange
    ff = fast_float(f, 'x', 'y')
    steps = int(steps)

    points = [ (start_x, start_y) ]
    for i in range(steps):
        xx, yy = points[-1]
        try:
            points.append( (xx + step_size , yy + step_size * ff(xx,yy)) )
        except (ValueError, ArithmeticError, TypeError):
            break

    starting_point = point(points[0], pointsize=50)
    solution = line(points)
    slope_field = plot_slope_field(f,(x,xmin,xmax), (y,ymin,ymax) )

    result = slope_field + starting_point + solution

    pretty_print(html(r"$\displaystyle\frac{dy}{dt} = %s$" %latex(f)))
    result.show(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax)
</script></div>


<br><br>
Euler's Method:
<div class="compute"><script type="text/x-sage">
x,y=var('x y')
from sage.ext.fast_eval import fast_float

@interact
def _(f = input_box(x*(1-y),label='f'),
      h = input_box(0.1),
      x0 = input_box(0),
      y0 = input_box(0.5),
      zoom=slider(1,10,default=3,step_size=1),
      table=true):
    ff = fast_float(f, 'x', 'y')
    pts = eulers_method(ff,x0,y0,h,zoom,algorithm="none")
    if table:
        eulers_method(ff,x0,y0,h,zoom,algorithm="table")
    P1 = list_plot(pts)
    P2 = line(pts)
    S = plot_slope_field(f,(x,-zoom,zoom),(y,-zoom,zoom))
    (P1+P2+S).show()
</script></div>

<h2 id="DE2">Differential Equations II: Separable DEs</h2>

Direction field and solutions for<br>
\[ \frac{dy}{dx} = -4xy^2: \]
<div class="compute"><script type="text/x-sage">
x,y = var('x y')
M=4
VF = plot_slope_field(-4*x*y^2,(x,-M,M),(y,-M,M),aspect_ratio=1)

@interact
def _(c = slider(-5,5,default=0,step_size=0.1), auto_update=false):
    show(r'y(x) = '+latex(1/(2*x^2+c)))
    show(VF+plot(1/(2*x^2+c),(x,-M,M),ymin=-M,ymax=M))
</script></div>
<br><br>

Direction field and solutions for<br>
\[ (4y - \cos(y))\frac{dy}{dx} - 3x^2 = 0: \]
<div class="compute"><script type="text/x-sage">
x,y = var('x y')
M=4
VF = plot_slope_field(3*x^2/(4*y-cos(y)),(x,-M,M),(y,-M,M),aspect_ratio=1)

@interact
def _(c = slider(-5,5,default=0,step_size=0.1), auto_update=false):
    show(r'2y^2-\sin(y)=x^3 + '+latex(c))
    show(VF+implicit_plot(2*y^2-sin(y)==x^3+c,(x,-M,M),(y,-M,M)))
</script></div>
<br><br>

Direction field and solutions for<br>
\[ \frac{dy}{dx} =y(1-y): \]
<div class="compute"><script type="text/x-sage">
x,y = var('x y')
M=4
VF = plot_slope_field(y*(1-y),(x,-M,M),(y,-M,M),aspect_ratio=1)

@interact
def _(A = slider(-10,10,default=0,step_size=0.1), auto_update=false):
    show(r'y(x) = '+latex(A*exp(x)/(1+A*exp(x))))
    show(VF+plot(A*exp(x)/(1+A*exp(x)),(x,-M,M),ymin=-M,ymax=M))
</script></div>
<br><br>

Something extra (not for exam purposes):
<h3 ID="SIR"> The SIR model of epidemics </h3>

We model the spread of a disease by dividing the population into three groups:
<li>S : those <it>Susceptible<it> to the disease, can get sick</li>
<li>I : those <it>Infected<it> with the disease, can spread the disease</li>
<li>R : those <it>Recovered<it> from the disease, are immune.</li>
<br>
I'll use the normalisation: \(S + I + R = 1\), i.e. these represent proportions of the population, rather
than absolute numbers of people.<br><br>

The assumptions are:
<li> The rate at which people get sick is proportional to the number of infected people times the number of susceptible people.
  This gives a term \(\beta I\cdot S = \beta I\cdot(1-I-R) \)</li>
<li> The rate at which people recover from the disease is propotional to the number of infected people.
  This gives a term \(\gamma I\).</li>
<li>Nobody dies, so \(S+I+R\) stays 1.</li>
<br><br>
This leads to the two differential Equations
\[
\frac{dI}{dt} = \beta I(1-I-R) - \gamma I
\]
\[
\frac{dR}{dt} = \gamma I
\]
(If people lose immunity over time, then we get an additional term \(-\delta R\) in the second DE.)<br><br>

We can solve these two linked DEs numerically using Euler's method:<br>
Choose a stepsize \(h\), start with initial values \(R_0, I_0\), then iterate:
\[
R_{n+1} = R_n + h\cdot \frac{dR}{dt}(R_n,I_n)
\]
\[
I_{n+1} = I_n + h\cdot \frac{dI}{dt}(R_n,I_n)
\]
This is essentially simulating the course of the epidemic in time steps of size \(h\).<br><br>

One can also compute the base reproductive number \(\mathcal{R}_0\),
which estimates how many people one infected individual would infect in a completely susceptible population.
It's given by \( \mathcal{R}_0 = \beta/\gamma \). <br><br>
For comparison: Flu has \( \mathcal{R}_0 \approx 1.5 \), the original SARS-CoV-2 has
\( \mathcal{R}_0 \approx 2.5-3.5\), the new Delta variant has
\( \mathcal{R}_0 \approx 5-8\)
and Measles has \( \mathcal{R}_0 \approx 12-18. \) That's why Measles vaccinations are so important!

<br><br>

Below, I also plot a "herd immunity threshold". For me, that's the value of \(S\) at which \(\frac{dI}{dt}=0\),
i.e. \( S = \gamma/\beta \). When this many people are susceptible, then the rate of new infections stops increasing.
If \(1 - \gamma/\beta = 1 - 1/\mathcal{R}_0\) of the people are immune, this means that the disease won't start a new epidemic.
One can achieve herd immunity by vaccinating (\(1-\gamma/\beta = 1 - 1/\mathcal{R}_0\) ) of the population.
<br><br>
In the interactive model below, you can set the base reproductive number \(\mathcal{R}_0\),
the parameter \(\gamma\), which you can think of as changing the unit of time
(it just scales the time variable \(t\) and doesn't change any other outcomes),
and also the optional parameter \(\delta\), which is the rate at which immunity wears
off over time.

You can also set the proportion of the population initially infected and recovered.
These are proportions, so 0.01 means 1% of the population.


<div class="compute"><script type="text/x-sage">
# SIR model
x,y,z = var('x y z')

show(r'\frac{dI}{dt} = \beta I\cdot S - \gamma I, \quad S + I + R = 1'+latex(''))
show(r'\frac{dR}{dt} = \gamma I - \delta R'+latex(''))

@interact
def _(Rnought = slider(0,20,default=2.5,step_size=0.01,label=r'\( \mathcal{R}_0 \)'),
     gamma = slider(0,1,default=0.05, step_size=0.01,label=r'\( \gamma \)'),
      delta = slider(0,1,default=0.0, step_size=0.01,label=r'\(\delta \)'),
     I_0 = input_box(0.01,label=r'\( \mathrm{Infected}_0 \)'),
     R_0 = input_box(0,label=r'\( \mathrm{Recovered}_0 \)'),
     h = input_box(1,label='step size'),
     steps = input_box(200),
     auto_update=false):
    beta = Rnought*gamma
#     show(r'\mathcal{R}_0 = '+latex(beta/gamma))
    VF = plot_vector_field((gamma*y-delta*x, beta*y*(1-x-y)-gamma*y), (x,0,1), (y,0,1),
                           color='black',aspect_ratio=1,axes_labels=['Recovered','Infected'])
    SL = streamline_plot((gamma*y-delta*x, beta*y*(1-x-y)-gamma*y), (x,0,1), (y,0,1),
                           color='lightgray')
    pts = [(R_0,I_0)]   # start at (R0,I0)
    R, I = R_0, I_0
    for i in range(steps):
        R = R + h*gamma*I - h*delta*R
        I = I + h*beta*I*(1-I-R) - h*gamma*I
        pts.append((R,I))
    L = line(pts,color='red', axes=false)
    H = plot(1-x-gamma/beta, (x,0,1), ymin=0, color='blue', linestyle='--', axes=false)
    show(SL+VF+H+L,axes=false)
    S_plot = list_plot([(i*h,1-p[0]-p[1]) for i,p in enumerate(pts)], plotjoined=True,
                       color='blue', legend_label = 'Susceptible')
    R_plot = list_plot([(i*h,p[0]) for i,p in enumerate(pts)], plotjoined=True,
                       color='green', legend_label = 'Recovered')
    I_plot = list_plot([(i*h,p[1]) for i,p in enumerate(pts)], plotjoined=True,
                       color='red', legend_label = 'Infected', axes_labels=['Time','Population'])
    H_plot = plot(gamma/beta, (x,0,steps*h), color='blue', linestyle='--', legend_label = 'Herd immunity threshold')
    show(S_plot+I_plot+R_plot+H_plot,ymax=1)
</script></div>

<h1 ID="DE6">Differential Equations VI: Applications</h1>

The second-order linear homogeneous differential equation
\[
\frac{d^2x}{dt^2} + \frac{D}{m}\frac{dx}{dt} + \frac{k}{m}x = 0
\]
has <em>damping parameter</em>
\[
\delta = \frac{p}{q} = \frac{D}{2m} / \sqrt{\frac{k}{m}} = \frac{D}{2\sqrt{km}}.
\]
The system is <em>under-damped</em> if the characteristic equation has complex roots (so \(\delta < 1 \)),
it is <em>over-damped</em> if the characteristic equation has two distinct real roots (so \(\delta > 1 \)),
and it is <em>critically damped</em> if the characteristic equation has a repeated real root (so \(\delta = 1\)).
<br><br>

<div class="compute"><script type="text/x-sage">
A = 1   # parameters in general solution
B = 0
m = 0.5   # mass 0.5kg
k = 0.5   # spring constant

t = var('t')

@interact
def _(D = slider(0,4,default=1,step_size=0.2), auto_update=false):
    p = D/(2*m)
    q = sqrt(k/m)
    d = p/q           # damping parameter
    w = abs(sqrt(q^2-p^2)) # frequency
    if d > 1:   # over-damped
        print("Over-damped: delta = ", d)
        y = A*exp((-p + w)*t) + B*exp((-p - w)*t)
    elif d == 1: # critcally damped
        print("Critically damped: delta = 1")
        y = (A+B*t)*exp(-p*t)
    else: # under-damped
        print("Under-damped: delta = ", d)
        y = exp(-p*t)*(A*cos(w*t) + B*sin(w*t))
    show(plot(y,(t,0,4*pi),aspect_ratio=6))
</script></div>

<br><br>
The amplitude of the long-term oscillation of a system with an applied force of the form
\( F_e = a\cos(\alpha t) \)
is proportional to
\[
M = \frac{1}{\sqrt{4p^2\alpha^2 + (\alpha^2-q^2)^2}}
\]
We plot this against the applied frequency \(\alpha\) for \(q=1\) and
various values of \(p\):



<div class="compute"><script type="text/x-sage">
q = 1
a = var('a')
plist = [0.1, 0.2, 0.5, 1, 2]
legends = ['p = '+str(p)[0:3] for p in plist]

plot([1/sqrt(4*p^2*a^2+(a^2-q^2)^2) for p in plist], (a, 0, 3),
     legend_label = legends, axes_labels = ['applied frequency', 'response'])
</script></div>

<br><br>
Now we can play with a damped oscillator with applied external force:<br>
(Note: Below, what I call \(x_c(t\)) is actually the solution to the IVP
with the right hand side set = 0, and \(x_p(t) = x(t) - x_c(t)\) is not
the same as the particular solution we guessed in class.)

<div class="compute"><script type="text/x-sage">
t = var('t')
x = function('x')(t)
alpha = var('alpha')

show(r'\[\frac{d^2 x}{dt^2} + \frac{D}{m}\frac{dx}{dt} + \frac{k}{m}x = a\cos(w t)\]')
# '
@interact
def _(D = ('damping D = ', slider(0, 5, default=1, step_size=0.1)),
      m = ('mass m = ', slider(0.1, 5, default=1, step_size=0.1)),
      k = ('spring k = ', slider(0.1, 5, default=1, step_size=0.1)),
      a = ('a = ', slider(0, 5, default=1, step_size=0.1)),
      w = ('w = ', slider(0, 5, default=1, step_size=0.1)),
      x0 = ('initial x(0) = ', slider(-5, 5, default=0, step_size=0.1)),
      xx0 = ("initial x'(0) = ", slider(-5, 5, default=0, step_size=0.1)),
      tmax = ('t_max ', slider(1, 100, default=20, step_size=1)),
      plotforce = ('show F_e(t)', true),
      plotxc = ('show x_c(t)', false),
      plotxp = ('show x_p(t)', false),
      plotfr = ('frequency response', true)
     ):
    sol = desolve(diff(x,t,2)+(D/m)*diff(x,t)+(k/m)*x == a*cos(w*t), x, ics=[0,x0,xx0])
    solc = desolve(diff(x,t,2)+(D/m)*diff(x,t)+(k/m)*x == 0, x, ics=[0,x0,xx0])
    solp = sol - solc
    p = D/(2*m)
    q = sqrt(k/m)
    d = p/q
    print('damping parameter d = ', d)
    show('x(t) = '+latex(sol))
    L = [sol]
    legend = ['x(t)']
    if plotforce:
        L.append(a*cos(w*t))
        legend.append('F_e(t)')
    if plotxc:
        L.append(solc)
        legend.append('x_c(t)')
        show('x_c(t) = '+latex(solc))
    if plotxp:
        L.append(solp)
        legend.append('x_p(t)')
        show('x_p(t) = '+latex(solp))
    show(plot(L, 0, tmax, axes_labels = ['t','x'], legend_label = legend))
    frcurve = plot(1/sqrt(4*p^2*alpha^2+(alpha^2-q^2)^2), (alpha, 0, 5*w),
         axes_labels = ['applied frequency w', 'response'])
    if plotfr:
        show(frcurve+line([(w,0),(w,frcurve.get_minmax_data()['ymax'])], color='red'),
             legend_label = ['amplitude', 'w = '+str(w)[0:3]])
</script></div>

<h1 ID="LA1">Linear Algebra I: Systems of Linear Equations</h1>

Solving equations via row reductions (Gauss-Jordan elimination):
<div class="compute"><script type="text/x-sage">
# Based on code by Pablo Angulo

# Coefficients are introduced as a matrix in a single text box,
# and independent terms as a vector in a separate text box. The number of equations and unknowns are arbitrary

from sage.misc.html import HtmlFragment

def SLE_as_latex(A, b, variables):
    nvars = A.ncols()
    pretty_print(HtmlFragment(
    r'$$\left\{\begin{array}{%s}'%('r'*(nvars+1))+
    r'\\'.join('%s \\; =&%s'%(
        (' & '.join((r'%s%s\cdot %s'%('+' if c>0 else '',c,v) if c else '') for c,v in zip(row, variables))
        if not row.is_zero() else '&'*(nvars-1)+'0',y)
               ) for row,y in zip(A,b))+
    r'\end{array}\right.$$'))

def extended_matrix_as_latex(M):
    A = M[:,:-1]
    b = M.column(-1)
    nvars = A.ncols()
    pretty_print(HtmlFragment(
    r'$$\left(\begin{array}{%s}'%('r'*nvars+ '|r')+
    r'\\'.join('%s&%s'%(
        ' & '.join('%s'%c for c in row)
        ,y) for row,y in zip(A,b))+
    r'\end{array}\right)$$'))

@interact
def SEL(A_text='[(0,0,-1,2),(-1,0,2,4), (0,0,1,-2)]',
        b_text='[2,1,-2]',
        auto_update=False
    ):
    A = matrix(QQ,eval(A_text))
    b = vector(eval(b_text))
    M = A.augment(b)
    neqs = len(b)
    nvars = A.ncols()
    var_names = ', '.join('x_%d'%j for j in [1..nvars])
    variables = var(var_names)
    pretty_print('Variables: %s'% var_names)
#    pretty_print(HtmlFragment('Variables: '+',\\;'.join([latex(v) for v in variables])))
#     for row,y in zip(A,b):
#         pretty_print(latex(sum(c*v for c,v in zip(row, variables))==y))

    pretty_print( HtmlFragment("Equations:"))
    SLE_as_latex(A, b, variables)
    pretty_print(HtmlFragment( 'We construct the augmented matrix:'))
    extended_matrix_as_latex(M)

    pivot = {}
    ibound_variables = []
    for m,row in enumerate(A):
        for k in range(m,nvars):
            lista = [(abs(M[j,k]),j) for j in range(m,neqs)]
            maxi, c = max(lista)
            if maxi > 0:
                ibound_variables.append(k)
                if M[m,k]==0:
                    M[c,:],M[m,:]=M[m,:],M[c,:]
                    pretty_print( HtmlFragment('We permute rows %d and %d:'%(m+1,c+1)))
                    extended_matrix_as_latex(M)
                pivot[m] = k
                break

        a=M[m,k]
        for n in range(m+1,neqs):
            if M[n,k]!=0:
                pretty_print( HtmlFragment("We add %s times row %d to row %d:"%(-M[n,k]/a, m+1, n+1)))
                M=M.with_added_multiple_of_row(n,m,-M[n,k]/a)
                extended_matrix_as_latex(M)

    for m,row in enumerate(M):
        k = 0
        while k < nvars-1 and row[k]==0:
            k = k+1
        if row[k]!=0 and row[k]!=0:
            pretty_print( HtmlFragment("We multiply row %d by %s:"%(m+1, 1/row[k])))
            M[m,:] = M[m,:]/row[k]
            extended_matrix_as_latex(M)
            for l in range(m):
                if M[l,k] != 0:
                    pretty_print( HtmlFragment("We add %s times row %d to row %d:"%(-M[l,k], m+1, l+1)))
                    M = M.with_added_multiple_of_row(l, m, -M[l,k])
                    extended_matrix_as_latex(M)

    pretty_print( HtmlFragment("Now our matrix is in reduced row-echelon form and our systems of equations is"))
    A = M[:,:-1]
    b = M.column(-1)
    SLE_as_latex(A, b, variables)
    SEL_type = 'compatible'
    null_rows = None
    for k,(row,y) in enumerate(zip(A,b)):
        if row.is_zero():
            if y==0 and null_rows is None:
                null_rows = k
                break
            elif y!=0:
                SEL_type = 'incompatible'
    if SEL_type == 'incompatible':
        pretty_print( HtmlFragment('The system has no solutions.'))
        return
    if null_rows:
        pretty_print(HtmlFragment('We remove trivial 0=0 equations:'))
        A = A[:null_rows,:]
        b = b[:null_rows]
        SLE_as_latex(A, b, variables)

    ifree_variables = [k for k in range(nvars) if k not in ibound_variables]
    bound_variables = [variables[k] for k in ibound_variables]
    free_variables = [variables[k] for k in ifree_variables]
    par_names = ', '.join('t_%d'%j for j in [1..len(free_variables)])
    if len(free_variables) > 0:
        if len(free_variables) > 1:
            params = list(var(par_names))
        else:
            params = [var('t_1')]
    if len(free_variables) > 0:
        pretty_print( 'Free variables: %s = %s'%(free_variables, params))
    pretty_print('Bound variables: %s'% bound_variables)

    reduced_eqs = [
        sum(c*v for c,v in zip(row, variables))==y
        for row,y in zip(A,b)
    ]
    xvector = vector(variables)
    if len(bound_variables)==1:
        soldict = solve(reduced_eqs, bound_variables[0], solution_dict=True)[0]
    else:
        soldict = solve(reduced_eqs, bound_variables, solution_dict=True)[0]
#     pretty_print( HtmlFragment('Solution in parametric form:'))
    parametric_sol = matrix(
        xvector.apply_map(lambda s:s.subs(soldict))
    ).transpose()
#     show(parametric_sol)
    pretty_print( 'Solution:')
#     pretty_print( HtmlFragment(
#         r'$$ %s + \left\langle %s\right\rangle$$'%(
#             latex(parametric_sol.subs(dict(zip(free_variables, [0]*len(free_variables))))),
#             ','.join(latex(
#             parametric_sol.apply_map(lambda s:s.diff(v))
#         ) for v in free_variables) if free_variables else latex(matrix([0]*nvars).transpose()))
#     ))
    if len(free_variables)>0:
        pretty_print( HtmlFragment(
            r'$$%s = %s + %s, \quad %s$$'%(
                latex(matrix(variables).transpose()),
                latex(parametric_sol.subs(dict(zip(free_variables, [0]*len(free_variables))))),
                '+'.join(latex(
                parametric_sol.apply_map(lambda s:s.diff(v))
            )+latex(params[j]) for j,v in enumerate(free_variables)),
            ',\\;'.join(latex(p) for p in params)+r'\in\mathbb{R}')
        ))
    else:
        pretty_print( HtmlFragment(
            r'$$%s = %s$$'%(
                latex(matrix(variables).transpose()),
                latex(parametric_sol.subs(dict(zip(free_variables, [0]*len(free_variables))))))
        ))
#     pretty_print( HtmlFragment('Dimension is %d'%len(free_variables)))
</script></div>

<h1 ID="LA3">Linear Algebra III: Matrices and Linear Transformations</h1>

<br><br>
Linear transformation in 2 dimensions:
<div class="compute"><script type="text/x-sage">
L=[(1,1),(1,0),(0,0),(0,1),(1,1),(0.5,1.5),(0,1),(0,1.4),(0.25,1.4),(0.25,1.25)]
example = [[1,0],[0,1]]

@interact
def _(A=input_grid(2,2, default = example,
                   label='A=', to_value=matrix),
      auto_update=false):
    print('det(A) = ',det(A))
    LA = list(map(lambda v: vector(A*matrix(2,1,list(v))), L))
    show(line(L, color='blue'), aspect_ratio=1, frame=true, title='Input')
    show(line(LA, color='red'), aspect_ratio=1, frame=true, title='Output')
    show(line(L, color='blue')+line(LA, color='red'),
        aspect_ratio=1, frame=true, title='Both')
</script></div>

<br><br>
As above, but with a rotation matrix
\[
A = \left( \begin{array}{ll} \cos\theta & -\sin\theta \\ \sin\theta & \cos\theta
\end{array}\right)
\]
<div class="compute"><script type="text/x-sage">
L=[(1,1),(1,0),(0,0),(0,1),(1,1),(0.5,1.5),(0,1),(0,1.4),(0.25,1.4),(0.25,1.25)]
example = [[1,0],[0,1]]

@interact
def _(theta=slider(-3.14,3.14,step_size=0.01,default=pi/3,label=r'\(\theta =\)'),
      auto_update=false):
    A = matrix(2,2,[cos(theta), -sin(theta), sin(theta), cos(theta)])
    show('A = '+latex(A))
    print('det(A) = ',det(A))
    LA = list(map(lambda v: vector(A*matrix(2,1,list(v))), L))
    show(line(L, color='blue'), aspect_ratio=1, frame=true, title='Input')
    show(line(LA, color='red'), aspect_ratio=1, frame=true, title='Output')
    show(line(L, color='blue')+line(LA, color='red'),
        aspect_ratio=1, frame=true, title='Both')
</script></div>

<br><br>
Linear transformation in 3 dimensions. Here we plot the effect of
a linear transformation on three unit vectors and the parallelepiped spanned by them.
<div class="compute"><script type="text/x-sage">
example = [[1,0,0],[0,1,0],[0,0,1]]
L = [(0,0,1),(0,1,0),(1,0,0)]
P = polytopes.parallelotope(L)
p1 = P.plot(opacity=0.5, color='blue')+\
arrow((0,0,0),L[0], color='blue')+\
arrow((0,0,0),L[1], color='blue')+\
arrow((0,0,0),L[2], color='blue')


@interact
def _(A=input_grid(3,3, default = example,
                   label='A='),
      auto_update=false):
    A = matrix(QQ,3,3,A)
    print('det(A) = ',det(A))
    LA = list(map(lambda v: vector(A*matrix(3,1,list(v))), L))
    PA = polytopes.parallelotope(LA)
    p2 = PA.plot(opacity=0.5, color='red')+\
    arrow((0,0,0),LA[0], color='red')+\
    arrow((0,0,0),LA[1], color='red')+\
    arrow((0,0,0),LA[2], color='red')
    print('Input:')
    show(p1, aspect_ratio=1)
    print('Output:')
    show(p2, aspect_ratio=1)
    print('Both:')
    show(p1+p2, aspect_ratio=1)

</script></div>

<h1 ID="LA4">Linear Algebra IV: Square matrices</h1>

<br><br>
Inverting a matrix using row reduction:<br><br>
<div class="compute"><script type="text/x-sage">
# Code by Hristo Inouzhe

#Choose the size D of the square matrix:
D = 3

example = [[1 if k==j else 0 for k in range(D)] for j in range(D)]
example[0][-1] = 2
example[-1][0] = 3

@interact
def _(M=input_grid(D,D, default = example,
                   label='Matrix to invert', to_value=matrix),
      tt = text_control('Enter the bits of precision used'
                        ' (only if you entered floating point numbers)'),
      precision = slider(5,100,5,20),
      auto_update=False):
    if det(M)==0:
        pretty_print('Failure: Matrix is not invertible')
        return
    if M.base_ring() == RR:
        M = M.apply_map(RealField(precision))
    N=M
    M=M.augment(identity_matrix(D))
    pretty_print('We construct the augmented matrix')
    show(M)
    for m in range(0,D-1):
        if M[m,m] == 0:
            lista = [(abs(M[j,m]),j) for j in range(m+1,D)]
            maxi, c = max(lista)
            M[c,:],M[m,:]=M[m,:],M[c,:]
            pretty_print('We permute rows %d and %d'%(m+1,c+1))
            show(M)
        for n in range(m+1,D):
            a=M[m,m]
            if M[n,m]!=0:
                pretty_print("We add %s times row %d to row %d"%(-M[n,m]/a, m+1, n+1))
                M=M.with_added_multiple_of_row(n,m,-M[n,m]/a)
                show(M)
    for m in range(D-1,-1,-1):
        for n in range(m-1,-1,-1):
            a=M[m,m]
            if M[n,m]!=0:
                pretty_print("We add %s times row %d to the row %d"%(-M[n,m]/a, m+1, n+1))
                M=M.with_added_multiple_of_row(n,m,-M[n,m]/a)
                show(M)
    for m in range(0,D):
        if M[m,m]!=1:
            pretty_print('We divide row %d by %s'%(m+1,M[m,m]))
            M = M.with_row_set_to_multiple_of_row(m,m,1/M[m,m])
            show(M)
    M=M.submatrix(0,D,D)
    pretty_print('We keep the right submatrix, which contains the inverse')
    show('M^{-1} = '+latex(M))
    pretty_print('We check it actually is the inverse')
    show('M^{-1}\\cdot M = '+latex(M)+'\\cdot'+latex(N)+' = '+latex(M*N))
</script></div>

<h1 ID="LA5">Linear Algebra V: Eigenvectors and Eigenvalues</h1>

For a square matrix \(A\), we say that \({\bf v}\) is an <i>eigevector</i>
of \(A\) with <i>eigenvalue</i> \(\lambda\), if
$$ A{\bf v} = \lambda{\bf v}$$.
<br><br>

In this example, the blue vector is a unit vector with angle \(\theta\), i.e.
\({\bf v} = (\cos(\theta), \sin(\theta))^T\), and the red vector is \(A{\bf v}\).
When they're parallel, you've found an eigenvector.
<div class="compute"><script type="text/x-sage">
example = [[1,2],[4,3]]

@interact
def _(A=input_grid(2,2, default = example,
                   label='A=', to_value=matrix),
      theta = slider(-3.15, 3.15, step_size=0.01, default=0),
      zoom = slider(1,20, step_size=1, default=5),
      auto_update=true):

    print('Eigenvectors: ', [v for (l, v, n) in A.eigenvectors_right()])
    print('Eigenvalues: ', [l for (l, v, n) in A.eigenvectors_right()])
    v = matrix(2,1,[cos(theta), sin(theta)])
    Av = A*v
    show(
        arrow((0,0), vector(v), color='blue')+\
        arrow((0,0), vector(Av), color='red'),
        aspect_ratio=1, frame=true, xmin=-zoom, xmax=zoom, ymin=-zoom, ymax=zoom
    )
</script></div>

<h1 ID="LA6">Linear Algebra VI: Applications of Eigenvalues and Eigenvectors</h1>

For a square matrix \(A\), let \(P\) be the matrix whose columns are the
eigenvectors of \(A\), and \(D\) the diagonal matrix whose diagonal entries
are the corresponding eigenvalues of \(A\), then we have
$$
A = PDP^{-1}.
$$
This can be useful for computing powers of \(A\), because
$$
A^n = PD^nP^{-1}
$$
and powers of a diagnoal matrix (such as \(D\)) are easy to compute.
We demonstrate this with the Fibonacci matrix:

<div class="compute"><script type="text/x-sage">
K.<a>=QuadraticField(5)
# We do our calculations in K so that Sagemath works with sqrt(5) exactly rather
# than approximating it with digits...
A = matrix(K,2,2,[0,1,1,1])
pretty_print('The Fibonacci matrix: ')
pretty_print('A = '+latex(A))
[(l1,[v1],n1),(l2,[v2],n2)] = A.eigenvectors_right(extend=false)
v1 = matrix(2,1,v1)  # turn v1 and v2 into 2x1 matrices
v2 = matrix(2,1,v2)
(D, P) = A.eigenmatrix_right()
pretty_print("Its eigenvalues are:")
pretty_print(r'\lambda_1 = '+latex(l1)+r',\qquad \lambda_2 = '+latex(l2))
pretty_print('With corresponding eigenvectors:')
pretty_print(r'{\bf v}_1 = '+latex(v1)+r',\qquad {\bf v}_2 = '+latex(v2))
pretty_print('We should have A = PDP^{-1} with')
# pretty_print(r'A = PDP^{-1}\;'+latex(''),'with')
pretty_print('P = '+latex(P)+r',\qquad D = '+latex(D))
pretty_print("Let's check it:")
pretty_print(r'PDP^{-1}\; =\; '+latex(P)+r'\cdot'+latex(D)+r'\cdot'+\
             latex(P.inverse())+r'\; = \;'+latex(P*D*P.inverse())+r'\; = \; A.')
pretty_print('Now powers of A are easy to compute: A^n = PD^nP^{-1}.')

@interact
def _(n = slider(0, 200, step_size=1, default=0)):
    pretty_print('A^{'+str(n)+'} = PD^{'+str(n)+'}P^{-1} = '+latex(P*D^n*P.inverse()))
    print()

</script></div>

<br><br>

Now Binet's Formula for the nth Fibonacci number is easily deduced by extracting
the top-right entry of \(A^n = PD^nP^{-1}\):

<div class="compute"><script type="text/x-sage">
pretty_print("Binet's Formula:  ", r'\;F_n = \frac{\phi^n - \bar{\phi}^n}{\sqrt{5}}'+latex(''))
phi = (1+sqrt(5))/2
phibar = (1-sqrt(5))/2
pretty_print(r'\phi \; = \;'+latex(phi)+r', \qquad \bar{\phi} \; = \;'+latex(phibar))
@interact
def _(n = slider(0, 200, step_size=1, default=0)):
    Fn = (phi^n-phibar^n)/sqrt(5)
    pretty_print('F_{'+str(n)+r'} = \;'+latex(round(Fn)))   # we use round(Fn) to force Sage to simplify it
</script></div>

<br><br>
You can play similar games with your own favourite matrix.
The following code is written specifically for 2x2 matrices, but in principle
this can be done with nxn matrices - so long as the matrix P of eigenvectors
is nxn and invertible (which is not always the case!).

<div class="compute"><script type="text/x-sage">
example = [[0,1],[1,1]]
@interact
def _(A=input_grid(2,2, default = example,
                   label='A =', to_value=matrix),
      n = slider(0, 200, step_size=1, default=0),
      auto_update=true):
    d = A.characteristic_polynomial().discriminant()
    if not is_square(d):
        K.<a> = QuadraticField(d.squarefree_part())
        A = matrix(K,2,2,A)
    (D, P) = A.eigenmatrix_right()
    pretty_print('We have', r'\; A = PDP^{-1}\;'+latex(''),'where')
    pretty_print(r'A \; = \; '+latex(A)+r', \qquad P \; = \;'+latex(P)+r',\qquad D \; = \;'+latex(D))
    pretty_print(r'A^{'+str(n)+r'} \;=\; PD^{'+str(n)+r'}P^{-1} \;=\; '+\
                 latex(P)+latex(D^n)+latex(P.inverse())+r'\; = \;'+latex(P*D^n*P.inverse()))

</script></div>

<h2>Your own computations</h2>
Type your own Sage computation below and click &ldquo;Evaluate&rdquo;.
<div class="compute"><script type="text/x-sage">
plot(sin(x), (x, 0, 2*pi))

</script></div>
<div class="compute"><script type="text/x-sage">
@interact
def f(n=(0,10)):
    print(2^n)
</script></div>
<br><br>
Is \(e^{\pi\sqrt{163}} \) an integer??<br><br>
<div class="compute"><script type="text/x-sage">
a=N(exp(pi*sqrt(163)),digits=30)
print(a.str(no_sci=2)[:30])
</script></div>
  </body>
</html>
