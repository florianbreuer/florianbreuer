<!DOCTYPE HTML>
<div>
<script type="text/javascript" async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</div>

<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>MATH1120 Sage Playground</title>
    <script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
    <script>
    // Make the div with id 'mycell' a Sage cell
    sagecell.makeSagecell({inputLocation:  '#mycell',
                           template:       sagecell.templates.minimal,
                           evalButtonText: 'Activate'});
    // Make *any* div with class 'compute' a Sage cell
    sagecell.makeSagecell({inputLocation: 'div.compute',
                           evalButtonText: 'Evaluate'});
    </script>
  </head>
  <body>


  <h1>Sage Playground for MATH1120 - 2021</h1>

  SageMath is a powerful open source mathematics package used by actual researchers.<br>

  You can download SageMath <a href="https://www.sagemath.org/">here</a>.<br>

  You can also just run Sage commands online, on this page or on the
  <a href="https://sagecell.sagemath.org/">Sage Cell Server</a>.<br>

  Sage <a href="https://doc.sagemath.org/html/en/tutorial/index.html">Tutorials</a> and documentation are
  <a href="https://doc.sagemath.org/">here</a>.<br>

<!--
  <h2>Factorial</h2>
  Click the &ldquo;Activate&rdquo; button below to calculate factorials.

<div id="mycell"><script type="text/x-sage">
@interact
def _(a=(1, 10)):
    print(factorial(a))
 </script>
</div>
-->

<h2>Calculus I : Maclaurin series</h2>
Plot terms of the Maclaurin series for \(\sin(x)\):
<div class="compute"><script type="text/x-sage">
x   = var('x')
x0  = 0
f   = sin(x)
p   = plot(f, -1, 2*pi, thickness=2)
dot = point((x0, f(x=x0)), pointsize=80, rgbcolor=(1, 0, 0))

@interact
def _(order=slider([1 .. 12])):
  ft = f.taylor(x, x0, order)
  pt = plot(ft, -1, 2*pi, color='green', thickness=2)
  pretty_print(html(r'$f(x)\;=\;%s$' % latex(f)))
  pretty_print(html(r'$T_{%s}f(x)\;=\;%s+\mathcal{O}(x^{%s})$' % (order, latex(ft), order+1)))
  show(dot + p + pt, ymin=-1, ymax=1)
</script></div>
<br>

<h2>Calculus III : Functions of Several Variables</h2>


<b>3D plots of functions we saw in class:</b><br><br>

\(f(x,y)=xy\):<br>
<div class="compute"><script type="text/x-sage">
x,y=var('x','y')
f=x*y
Mx=1
My=1
plot3d(f,(x,-Mx,Mx),(y,-My,My))
</script></div>

<br>
The sombrero:
\(f(x,y)=1-\sqrt{x^2+y^2}e^{-(x^2+y^2)}\):<br>
<div class="compute"><script type="text/x-sage">
x,y=var('x','y')
f=1-sqrt(x^2+y^2)*exp(-x^2-y^2)
Mx=1
My=1
plot3d(f,(x,-Mx,Mx),(y,-My,My))
</script></div>

<br>
Now we plot both the 3D graph and a contour plot:<br>
\( f(x,y)=\sin(y)e^{x/5}\)<br>
<div class="compute"><script type="text/x-sage">
x,y=var('x','y')
f=sin(y)*exp(x/5)
Mx=10
My=10
show(plot3d(f,(x,-Mx,Mx),(y,-My,My)),plot_points=500,adaptive=true)
show(contour_plot(f,(x,-Mx,Mx),(y,-My,My),colorbar=True,labels=True,contours=30,plot_points=500))
</script></div>

<h2>Calculus V : Tangent Planes</h2>

Play with linear approximations<br>
<div class="compute"><script type="text/x-sage">
x,y=var('x','y')

#f = 5-(x^2+y^2)/2
f = x*y

Mx=3
My=3
fx=diff(f,x)
fy=diff(f,y)
show('f(x,y)='+latex(f(x=x,y=y)))
show(r'f_x=\frac{\partial f}{\partial x} = '+latex(fx))
show(r'f_y=\frac{\partial f}{\partial y} = '+latex(fy))

@interact
def _(x0=slider(-Mx,Mx,step_size=0.1),y0=slider(-My,My,step_size=0.1),auto_update=False):
    L = f(x=x0,y=y0)+fx(x=x0,y=y0)*(x-x0)+fy(x=x0,y=y0)*(y-y0)
    show('(x_0,y_0)='+latex((x0,y0)))
    show('(f_x('+latex(x0)+'),f_y('+latex(y0)+'))='+latex((fx(x=x0,y=y0),fy(x=x0,y=y0))))
    show('L(x,y)='+latex(L(x=x,y=y)))
    show(plot3d(f,(x,-Mx,Mx),(y,-My,My),color='blue')+plot3d(L,(x,-Mx,Mx),(y,-My,My),color='red'))
</script></div>


<br>
Tangent plane to the implicitly defined surface in class:<br>
The tangent plane to \( z-yz^3=x+2\) at the point \((x_0,y_0,z_0)=(2,0,3)\): <br>
<div class="compute"><script type="text/x-sage">
x,y,z=var('x','y','z')
implicit_plot3d(z-y*z^3==x+2,(x,-4,4),(y,-4,4),(z,-4,4),color='blue')+\
implicit_plot3d(z==x+27*y+2,(x,-4,4),(y,-4,4),(z,-4,4),color='red')
</script></div>

<h2>Calculus VI : Directional derivative and gradient vectors</h2>

Here we plot the function
\[ f(x,y) = xy+y^2-x^3, \]
its level curves and the gradient vectors \(\nabla f\) (in red):<br><br>

<div class="compute"><script type="text/x-sage">
x,y=var('x','y')
M=1
f=x*y+y^2-x^3
#f=x*y
show('f(x,y)='+latex(f))
show(contour_plot(f,(x,-M,M),(y,-M,M),contours=30,fill=false)+\
     plot_vector_field(f.gradient(),(x,-M,M),(y,-M,M),color='red'))
show(plot3d(f,(x,-M,M),(y,-M,M)))
</script></div>
(You can uncomment the line <tt>f=x*y</tt> to plot \( f(x,y) = xy \),
or replace it with any function of your choice.)
<br><br>

For functions of three variables, the gradient vector is perpendicular to <thead>
  level surfaces of the function. We can use this to obtain an equation for
the tangent plane of a surface. <br><br>

For example, we compute the tangent plane
to the surface \( xy+yz^2+xz^3 = 54 \) at the point \( (2,0,3) \). <br>
This surface is a level surface of the function
\( f(x,y,z) = xy+yz^2+xz^3 \).
The gradient vector is then a normal vector for the surface, and we have a point
on the surface, and this lets us determine an equation for the
tangent surface:
\[
L : f_x(2,0,3)(x-2) + f_y(2,0,3)(y-0) + f_z(2,0,3)(z-3) = 0.
\]


<div class="compute"><script type="text/x-sage">
x,y,z = var('x','y','z')

f=x*y+y*z^2+x*z^3
(x0,y0,z0) = (2,0,3)

M=5
fx=diff(f,x)
fy=diff(f,y)
fz=diff(f,z)

L = fx(x=x0,y=y0,z=z0)*(x-x0)+fy(x=x0,y=y0,z=z0)*(y-y0)+fz(x=x0,y=y0,z=z0)*(z-z0)

show("f(x,y,z)="+latex(f))
show(r"\nabla f(x,y,z) = "+latex(f.gradient()))
show(r"(x_0,y_0,z_0) = "+latex((x0,y0,z0)))
show(r"\text{Tangent plane: }"+latex(L)+" = 0")

show(
    implicit_plot3d(f==f(x=x0,y=y0,z=z0),(x,-M,M),(y,-M,M),(z,-M,M),plot_points=100)+\
    implicit_plot3d(L==0,(x,-M,M),(y,-M,M),(z,-M,M),plot_points=100,color='red')+\
    sphere((x0,y0,z0),0.1,color='black')
)
</script></div>


<h2>Calculus VII: Global Minima and Maxima</h2>

The critical points of the function \( f(x,y) = 2x^3+(x+1)y^2+5x^2 \):
<div class="compute"><script type="text/x-sage">
x,y = var('x','y')
f=2*x^3+(x+1)*y^2+5*x^2
show("f(x,y) = "+latex(f))
show(
    plot3d(f,(x,-2,1),(y,-3,3),plot_points=100,aspect_ratio=[1,1,0.2])+\
    sphere((0,0,f(x=0,y=0)),0.1,color='red')+\
    sphere((-5/3,0,f(x=-5/3,y=0)),0.1,color='red')+\
    sphere((-1,2,f(x=-1,y=2)),0.1,color='red')+\
    sphere((-1,-2,f(x=-1,y=-2)),0.1,color='red')
)
show(
    contour_plot(f,(x,-2,1),(y,-3,3),plot_points=100,contours=40,fill=false)+\
    circle((0,0),0.01,color='red')+\
    circle((-5/3,0),0.01,color='red')+\
    circle((-1,2),0.01,color='red')+\
    circle((-1,-2),0.01,color='red')
)
</script></div>

<br><br>
Another example:
The critical points of the function \( f(x,y) = 3x-x^3-2y^2+y^4 \):
<div class="compute"><script type="text/x-sage">
x,y=var('x y')
f=3*x-x^3-2*y^2+y^4
crits = [(1,0),(1,1),(1,-1),(-1,0),(-1,1),(-1,-1)]
M=2
show(
    plot3d(f,(x,-M,M),(y,-M,M),plot_points=100,aspect_ratio=[1,1,0.3],opacity=0.9)+\
    sum(sphere((P[0],P[1],f(x=P[0],y=P[1])),0.1,color='red') for P in crits)
)
show(
    contour_plot(f,(x,-M,M),(y,-M,M),plot_points=500,contours=40,fill=false)+\
    sum([circle(P,0.02,color='red') for P in crits])
)
</script></div>

<br><br>
Global maximum and minimum of \( f(x,y) = 2x^2+x+y^2-2 \) on the disc
\( D = \{ (x,y)\in\mathbb{R}^2 \;|\; x^2+y^2 \leq 4 \} \):
<div class="compute"><script type="text/x-sage">
r,t=var('r t')
parametric_plot3d((r*cos(t),r*sin(t),2*(r*cos(t))^2+r*cos(t)+(r*sin(t))^2-2),(t,0,2*pi),(r,0,2),
opacity=0.9,aspect_ratio=[1,1,0.3])+sphere((-1/4,0,-17/8),0.1,color='red')+sphere((2,0,8),0.1,color='red')
</script></div>


<h2>Calculus VIII: Chain Rules</h2>

The magic formula for implicit differentiation:
If \( f(x,y) = c \) defines \( y(x) \) implicitly as a function of \(x\), then
\[
\frac{dy}{dx} = -\frac{f_x}{f_y}.
\]
<div class="compute"><script type="text/x-sage">
x,y = var('x y')
M = 5

f = x*cos(y)+y*cos(x)-x

fx = diff(f,x)
fy = diff(f,y)

show(r"\frac{dy}{dy} = "+latex(-fx/fy))

@interact
def _(c=slider(-5,5,step_size=0.1,default=0),
    auto_update=true,
    slopes = true,
    gradient = false,
    show3d = false):
    show(r"f(x,y) = "+latex(f)+r" = "+latex(c))
    P = implicit_plot(f==c,(x,-M,M),(y,-M,M))
    if slopes:
        P=P+plot_slope_field(-fx/fy,(x,-M,M),(y,-M,M),plot_points=30,color='gray')
    if gradient:
        P=P+plot_vector_field(f.gradient(),(x,-M,M),(y,-M,M),plot_points=30,color='red')
    show(P)
    if show3d:
        show(plot3d(f,(x,-M,M),(y,-M,M),aspect_ratio=[1,1,0.5])+plot3d(c,(x,-M,M),(y,-M,M),opacity=0.5,color='pink'))
</script></div>

<h2>Differential Equations I: Direction Fields and Euler's Method</h2>

Plot the firection field of \(\frac{dy}{dx} = f(x,y)\), as well as a particular solution:
<div class="compute"><script type="text/x-sage">
x,y = var('x,y')
from sage.ext.fast_eval import fast_float
@interact
def _(f=input_box(default=x-y),
      xrange=range_slider(-10,10,default=(-2,2)),
      yrange=range_slider(-10,10,default=(-2,2)),
      start_x=input_box(default=-2), start_y=input_box(default=0.5),
      #start_y = slider(-2,2,default=0,step_size=0.1),
      step_size=slider(0.01,0.2,step_size=0.01), steps=(600,(0, 1400)), auto_update=false ):
    (xmin,xmax)=xrange
    (ymin,ymax)=yrange
    ff = fast_float(f, 'x', 'y')
    steps = int(steps)

    points = [ (start_x, start_y) ]
    for i in range(steps):
        xx, yy = points[-1]
        try:
            points.append( (xx + step_size , yy + step_size * ff(xx,yy)) )
        except (ValueError, ArithmeticError, TypeError):
            break

    starting_point = point(points[0], pointsize=50)
    solution = line(points)
    slope_field = plot_slope_field(f,(x,xmin,xmax), (y,ymin,ymax) )

    result = slope_field + starting_point + solution

    pretty_print(html(r"$ \displaystyle\frac{dy}{dt} = %s$" %latex(f)))
    result.show(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax)
</script></div>


<br><br>
Euler's Method:
<div class="compute"><script type="text/x-sage">
x,y=var('x y')
from sage.ext.fast_eval import fast_float

@interact
def _(f = input_box(x*(1-y),label='f'),
      h = input_box(0.1),
      x0 = input_box(0),
      y0 = input_box(0.5),
      zoom=slider(1,10,default=3,step_size=1),
      table=true):
    ff = fast_float(f, 'x', 'y')
    pts = eulers_method(ff,x0,y0,h,zoom,algorithm="none")
    if table:
        eulers_method(ff,x0,y0,h,zoom,algorithm="table")
    P1 = list_plot(pts)
    P2 = line(pts)
    S = plot_slope_field(f,(x,-zoom,zoom),(y,-zoom,zoom))
    (P1+P2+S).show()
</script></div>

<h1>Differential Equations II: Separable DEs</h1>

Direction field and solutions for<br>
\[ \frac{dy}{dx} = -4xy^2: \]
<div class="compute"><script type="text/x-sage">
x,y = var('x y')
M=4
VF = plot_slope_field(-4*x*y^2,(x,-M,M),(y,-M,M),aspect_ratio=1)

@interact
def _(c = slider(-5,5,default=0,step_size=0.1), auto_update=false):
    show(r'y(x) = '+latex(1/(2*x^2+c)))
    show(VF+plot(1/(2*x^2+c),(x,-M,M),ymin=-M,ymax=M))
</script></div>
<br><br>

Direction field and solutions for<br>
\[ (4y - \cos(y))\frac{dy}{dx} - 3t^2 = 0: \]
<div class="compute"><script type="text/x-sage">
x,y = var('x y')
M=4
VF = plot_slope_field(3*x^2/(4*y-cos(y)),(x,-M,M),(y,-M,M),aspect_ratio=1)

@interact
def _(c = slider(-5,5,default=0,step_size=0.1), auto_update=false):
    show(r'2y^2-\sin(y)=x^3 + '+latex(c))
    show(VF+implicit_plot(2*y^2-sin(y)==x^3+c,(x,-M,M),(y,-M,M)))
</script></div>
<br><br>

Direction field and solutions for<br>
\[ \frac{dy}{dx} =y(1-y): \]
<div class="compute"><script type="text/x-sage">
x,y = var('x y')
M=4
VF = plot_slope_field(y*(1-y),(x,-M,M),(y,-M,M),aspect_ratio=1)

@interact
def _(A = slider(-10,10,default=0,step_size=0.1), auto_update=false):
    show(r'y(x) = '+latex(A*exp(x)/(1+A*exp(x))))
    show(VF+plot(A*exp(x)/(1+A*exp(x)),(x,-M,M),ymin=-M,ymax=M))
</script></div>
<br><br>

Something extra (not for exam purposes):
<h3> The SIR model of epidemics </h3>

We model the spread of a disease by dividing the population into three groups:
<li>S : those <it>Susceptible<it> to the disease, can get sick</li>
<li>I : those <it>Infected<it> with the disease, can spread the disease</li>
<li>R : those <it>Recovered<it> from the disease, are immune.</li>
<br>
I'll use the normalisation: \(S + I + R = 1\), i.e. these represent proportions of the population, rather
than absolute numbers of people.<br><br>

The assumptions are:
<li> The rate at which people get sick is proportional to the number of infected people times the number of susceptible people.
  This gives a term \(\beta I\cdot S = \beta I\cdot(1-I-R) \)</li>
<li> The rate at which people recover from the disease is propotional to the number of infected people.
  This gives a term \(\gamma I\).</li>
<li>Nobody dies, so \(S+I+R\) stays 1.</li>
<br><br>
This leads to the two differential Equations
\[
\frac{dI}{dt} = \beta I(1-I-R) - \gamma I
\]
\[
\frac{dR}{dt} = \gamma I
\]
(If people lose immunity over time, then we get an additional term \(-\delta R\) in the second DE.)<br><br>

We can solve these two linked DEs numerically using Euler's method:<br>
Choose a stepsize \(h\), start with initial values \(R_0, I_0\), then iterate:
\[
R_{n+1} = R_n + h\cdot \frac{dR}{dt}(R_n,I_n)
\]
\[
I_{n+1} = I_n + h\cdot \frac{dI}{dt}(R_n,I_n)
\]
This is essentially simulating the course of the epidemic in time steps of size \(h\).<br><br>

One can also compute the base reproductive number \(\mathcal{R}_0\) (not to be confused with \(R(0)\) ),
which estimates how many people one infected individual would infect in a completely susceptible population.
It's given by \( \mathcal{R}_0 = \beta/\gamma \). <br><br>
For comparison: Flu has \( \mathcal{R}_0 \approx 1.5 \), SARS-CoV-19 has \( \mathcal{R}_0 \approx 2.5-3.5\),
and Measles has \( \mathcal{R}_0 \approx 12-18. \) That's why Measles vaccinations are so important!

<br><br>

Below, I also plot a "herd immunity threshold". For me, that's the value of \(S\) at which \(\frac{dI}{dt}=0\),
i.e. \( S = \gamma/\beta \). When this many people are susceptible, then the rate of new infections stops increasing.
If \(1 - \gamma/\beta\) of the people are immune, this means that the disease won't start a new epidemic.
One can achieve herd immunity by vaccinating (\(1-\gamma/\beta\) ) of the population.


<div class="compute"><script type="text/x-sage">
# SIR model
x,y,z = var('x y z')

show(r'\frac{dI}{dt} = \beta I\cdot S - \gamma I, \quad S + I + R = 1'+latex(''))
show(r'\frac{dR}{dt} = \gamma I - \delta R'+latex(''))

@interact
def _(beta = slider(0,1,default=0.15,step_size=0.01,label=r'\( \beta \)'),
     gamma = slider(0,1,default=0.05, step_size=0.01,label=r'\( \gamma \)'),
      delta = slider(0,1,default=0.0, step_size=0.01,label=r'\(\delta \)'),
     I_0 = input_box(0.05,label=r'\( \mathrm{Infected}_0 \)'),
     R_0 = input_box(0,label=r'\( \mathrm{Recovered}_0 \)'),
     h = input_box(1,label='step size'),
     steps = input_box(200),
     auto_update=false):
    show(r'\mathcal{R}_0 = '+latex(beta/gamma))
    VF = plot_vector_field((gamma*y-delta*x, beta*y*(1-x-y)-gamma*y), (x,0,1), (y,0,1),
                           color='black',aspect_ratio=1,axes_labels=['Recovered','Infected'])
    SL = streamline_plot((gamma*y-delta*x, beta*y*(1-x-y)-gamma*y), (x,0,1), (y,0,1),
                           color='lightgray')
    pts = [(R_0,I_0)]   # start at (R0,I0)
    R, I = R_0, I_0
    for i in range(steps):
        R = R + h*gamma*I - h*delta*R
        I = I + h*beta*I*(1-I-R) - h*gamma*I
        pts.append((R,I))
    L = line(pts,color='red', axes=false)
    H = plot(1-x-gamma/beta, (x,0,1), ymin=0, color='blue', linestyle='--', axes=false)
    show(SL+VF+H+L,axes=false)
    S_plot = list_plot([(i*h,1-p[0]-p[1]) for i,p in enumerate(pts)], plotjoined=True,
                       color='blue', legend_label = 'Susceptible')
    R_plot = list_plot([(i*h,p[0]) for i,p in enumerate(pts)], plotjoined=True,
                       color='green', legend_label = 'Recovered')
    I_plot = list_plot([(i*h,p[1]) for i,p in enumerate(pts)], plotjoined=True,
                       color='red', legend_label = 'Infected', axes_labels=['Time','Population'])
    H_plot = plot(gamma/beta, (x,0,steps*h), color='blue', linestyle='--', legend_label = 'Herd immunity threshold')
    show(S_plot+I_plot+R_plot+H_plot,ymax=1)
</script></div>

<h1>Differential Equations VI: Applications</h1>

The second-order linear homogeneous differential equation
\[
\frac{d^2x}{dt^2} + \frac{D}{m}\frac{dx}{dt} + \frac{k}{m}x = 0
\]
has <em>damping parameter</em>
\[
\delta = \frac{p}{q} = \frac{D}{2m} / \sqrt{\frac{k}{m}} = \frac{D}{2\sqrt{km}}.
\]
The system is <em>under-damped</em> if the characteristic equation has complex roots (so \(\delta < 1 \)),
it is <em>over-damped</em> if the characteristic equation has two distinct real roots (so \(\delta > 1 \)),
and it is <em>critically damped</em> if the characteristic equation has a repeated real root (so \(\delta = 1\)).
<br><br>

<div class="compute"><script type="text/x-sage">
A = 1   # parameters in general solution
B = 0
m = 0.5   # mass 0.5kg
k = 0.5   # spring constant

t = var('t')

@interact
def _(D = slider(0,4,default=1,step_size=0.2), auto_update=false):
    p = D/(2*m)
    q = sqrt(k/m)
    d = p/q           # damping parameter
    w = abs(sqrt(q^2-p^2)) # frequency
    if d > 1:   # over-damped
        print("Over-damped: delta = ", d)
        y = A*exp((-p + w)*t) + B*exp((-p - w)*t)
    elif d == 1: # critcally damped
        print("Critically damped: delta = 1")
        y = (A+B*t)*exp(-p*t)
    else: # under-damped
        print("Under-damped: delta = ", d)
        y = exp(-p*t)*(A*cos(w*t) + B*sin(w*t))
    show(plot(y,(t,0,4*pi),aspect_ratio=6))
</script></div>

<br><br>
The amplitude of the long-term oscillation of a system with an applied force of the form
\( F_e = a\cos(\alpha t) \)
is proportional to
\[
M = \frac{1}{\sqrt{4p^2\alpha^2 + (\alpha^2-q^2)^2}}
\]
We plot this against the applied frequency \(\alpha\) for \(q=1\) and
various values of \(p\):



<div class="compute"><script type="text/x-sage">
q = 1
a = var('a')
plist = [0.1, 0.2, 0.5, 1, 2]
legends = ['p = '+str(p)[0:3] for p in plist]

plot([1/sqrt(4*p^2*a^2+(a^2-q^2)^2) for p in plist], (a, 0, 3),
     legend_label = legends, axes_labels = ['applied frequency', 'response'])
</script></div>

<br><br>
Now we can play with a damped oscillator with applied external force:<br>
(Note: Below, what I call \(x_c(t\)) is actually the solution to the IVP
with the right hand side set = 0, and \(x_p(t) = x(t) - x_c(t)\) is not
the same as the particular solution we guessed in class.)

<div class="compute"><script type="text/x-sage">
t = var('t')
x = function('x')(t)
alpha = var('alpha')

show(r'\frac{d^2x}{dt^2} + \frac{D}{m}\frac{dx}{dt} + \frac{k}{m}x = a\cos(w t)'+latex(''))

@interact
def _(D = ('damping D = ', slider(0, 5, default=1, step_size=0.1)),
      m = ('mass m = ', slider(0.1, 5, default=1, step_size=0.1)),
      k = ('spring k = ', slider(0.1, 5, default=1, step_size=0.1)),
      a = ('a = ', slider(0, 5, default=1, step_size=0.1)),
      w = ('w = ', slider(0, 5, default=1, step_size=0.1)),
      x0 = ('initial x(0) = ', slider(-5, 5, default=0, step_size=0.1)),
      xx0 = ("initial x'(0) = ", slider(-5, 5, default=0, step_size=0.1)),
      tmax = ('t_max ', slider(1, 100, default=20, step_size=1)),
      plotforce = ('show F_e(t)', true),
      plotxc = ('show x_c(t)', false),
      plotxp = ('show x_p(t)', false),
      plotfr = ('frequency response', true)
     ):
    sol = desolve(diff(x,t,2)+(D/m)*diff(x,t)+(k/m)*x == a*cos(w*t), x, ics=[0,x0,xx0])
    solc = desolve(diff(x,t,2)+(D/m)*diff(x,t)+(k/m)*x == 0, x, ics=[0,x0,xx0])
    solp = sol - solc
    p = D/(2*m)
    q = sqrt(k/m)
    d = p/q
    print('damping parameter d = ', d)
    show('x(t) = '+latex(sol))
    L = [sol]
    legend = ['x(t)']
    if plotforce:
        L.append(a*cos(w*t))
        legend.append('F_e(t)')
    if plotxc:
        L.append(solc)
        legend.append('x_c(t)')
        show('x_c(t) = '+latex(solc))
    if plotxp:
        L.append(solp)
        legend.append('x_p(t)')
        show('x_p(t) = '+latex(solp))
    show(plot(L, 0, tmax, axes_labels = ['t','x'], legend_label = legend))
    frcurve = plot(1/sqrt(4*p^2*alpha^2+(alpha^2-q^2)^2), (alpha, 0, 5*w),
         axes_labels = ['applied frequency w', 'response'])
    if plotfr:
        show(frcurve+line([(w,0),(w,frcurve.get_minmax_data()['ymax'])], color='red'),
             legend_label = ['amplitude', 'w = '+str(w)[0:3]])
</script></div>

<h1>Linear Algebra I: Systems of Linear Equations</h1>

Solving equations via row reductions (Gauss-Jordan elimination):
<div class="compute"><script type="text/x-sage">
# Based on code by Pablo Angulo

# Coefficients are introduced as a matrix in a single text box,
# and independent terms as a vector in a separate text box. The number of equations and unknowns are arbitrary

from sage.misc.html import HtmlFragment

def SLE_as_latex(A, b, variables):
    nvars = A.ncols()
    pretty_print(HtmlFragment(
    r'$$\left\{\begin{array}{%s}'%('r'*(nvars+1))+
    r'\\'.join('%s \\; =&%s'%(
        (' & '.join((r'%s%s\cdot %s'%('+' if c>0 else '',c,v) if c else '') for c,v in zip(row, variables))
        if not row.is_zero() else '&'*(nvars-1)+'0',y)
               ) for row,y in zip(A,b))+
    r'\end{array}\right.$$'))

def extended_matrix_as_latex(M):
    A = M[:,:-1]
    b = M.column(-1)
    nvars = A.ncols()
    pretty_print(HtmlFragment(
    r'$$\left(\begin{array}{%s}'%('r'*nvars+ '|r')+
    r'\\'.join('%s&%s'%(
        ' & '.join('%s'%c for c in row)
        ,y) for row,y in zip(A,b))+
    r'\end{array}\right)$$'))

@interact
def SEL(A_text='[(0,0,-1,2),(-1,0,2,4), (0,0,1,-2)]',
        b_text='[2,1,-2]',
        auto_update=False
    ):
    A = matrix(QQ,eval(A_text))
    b = vector(eval(b_text))
    M = A.augment(b)
    neqs = len(b)
    nvars = A.ncols()
    var_names = ', '.join('x_%d'%j for j in [1..nvars])
    variables = var(var_names)
    pretty_print('Variables: %s'% var_names)
#    pretty_print(HtmlFragment('Variables: $'+',\\;'.join([latex(v) for v in variables])+'$'))
#     for row,y in zip(A,b):
#         pretty_print(latex(sum(c*v for c,v in zip(row, variables))==y))

    pretty_print( HtmlFragment("Equations:"))
    SLE_as_latex(A, b, variables)
    pretty_print(HtmlFragment( 'We construct the augmented matrix:'))
    extended_matrix_as_latex(M)

    pivot = {}
    ibound_variables = []
    for m,row in enumerate(A):
        for k in range(m,nvars):
            lista = [(abs(M[j,k]),j) for j in range(m,neqs)]
            maxi, c = max(lista)
            if maxi > 0:
                ibound_variables.append(k)
                if M[m,k]==0:
                    M[c,:],M[m,:]=M[m,:],M[c,:]
                    pretty_print( HtmlFragment('We permute rows %d and %d:'%(m+1,c+1)))
                    extended_matrix_as_latex(M)
                pivot[m] = k
                break

        a=M[m,k]
        for n in range(m+1,neqs):
            if M[n,k]!=0:
                pretty_print( HtmlFragment("We add %s times row %d to row %d:"%(-M[n,k]/a, m+1, n+1)))
                M=M.with_added_multiple_of_row(n,m,-M[n,k]/a)
                extended_matrix_as_latex(M)

    for m,row in enumerate(M):
        k = 0
        while k < nvars-1 and row[k]==0:
            k = k+1
        if row[k]!=0 and row[k]!=0:
            pretty_print( HtmlFragment("We multiply row %d by %s:"%(m+1, 1/row[k])))
            M[m,:] = M[m,:]/row[k]
            extended_matrix_as_latex(M)
            for l in range(m):
                if M[l,k] != 0:
                    pretty_print( HtmlFragment("We add %s times row %d to row %d:"%(-M[l,k], m+1, l+1)))
                    M = M.with_added_multiple_of_row(l, m, -M[l,k])
                    extended_matrix_as_latex(M)

    pretty_print( HtmlFragment("Now our matrix is in reduced row-echelon form and our systems of equations is"))
    A = M[:,:-1]
    b = M.column(-1)
    SLE_as_latex(A, b, variables)
    SEL_type = 'compatible'
    null_rows = None
    for k,(row,y) in enumerate(zip(A,b)):
        if row.is_zero():
            if y==0 and null_rows is None:
                null_rows = k
                break
            elif y!=0:
                SEL_type = 'incompatible'
    if SEL_type == 'incompatible':
        pretty_print( HtmlFragment('The system has no solutions.'))
        return
    if null_rows:
        pretty_print(HtmlFragment('We remove trivial 0=0 equations:'))
        A = A[:null_rows,:]
        b = b[:null_rows]
        SLE_as_latex(A, b, variables)

    ifree_variables = [k for k in range(nvars) if k not in ibound_variables]
    bound_variables = [variables[k] for k in ibound_variables]
    free_variables = [variables[k] for k in ifree_variables]
    par_names = ', '.join('t_%d'%j for j in [1..len(free_variables)])
    if len(free_variables) > 0:
        if len(free_variables) > 1:
            params = list(var(par_names))
        else:
            params = [var('t_1')]
    if len(free_variables) > 0:
        pretty_print( 'Free variables: %s = %s'%(free_variables, params))
    pretty_print('Bound variables: %s'% bound_variables)

    reduced_eqs = [
        sum(c*v for c,v in zip(row, variables))==y
        for row,y in zip(A,b)
    ]
    xvector = vector(variables)
    if len(bound_variables)==1:
        soldict = solve(reduced_eqs, bound_variables[0], solution_dict=True)[0]
    else:
        soldict = solve(reduced_eqs, bound_variables, solution_dict=True)[0]
#     pretty_print( HtmlFragment('Solution in parametric form:'))
    parametric_sol = matrix(
        xvector.apply_map(lambda s:s.subs(soldict))
    ).transpose()
#     show(parametric_sol)
    pretty_print( 'Solution:')
#     pretty_print( HtmlFragment(
#         r'$$ %s + \left\langle %s\right\rangle$$'%(
#             latex(parametric_sol.subs(dict(zip(free_variables, [0]*len(free_variables))))),
#             ','.join(latex(
#             parametric_sol.apply_map(lambda s:s.diff(v))
#         ) for v in free_variables) if free_variables else latex(matrix([0]*nvars).transpose()))
#     ))
    if len(free_variables)>0:
        pretty_print( HtmlFragment(
            r'$$%s = %s + %s, \quad %s$$'%(
                latex(matrix(variables).transpose()),
                latex(parametric_sol.subs(dict(zip(free_variables, [0]*len(free_variables))))),
                '+'.join(latex(
                parametric_sol.apply_map(lambda s:s.diff(v))
            )+latex(params[j]) for j,v in enumerate(free_variables)),
            ',\\;'.join(latex(p) for p in params)+r'\in\mathbb{R}')
        ))
    else:
        pretty_print( HtmlFragment(
            r'$$%s = %s$$'%(
                latex(matrix(variables).transpose()),
                latex(parametric_sol.subs(dict(zip(free_variables, [0]*len(free_variables))))))
        ))
#     pretty_print( HtmlFragment('Dimension is %d'%len(free_variables)))
</script></div>

<h1>Linear Algebra III: Matrices and Linear Transformations</h1>

<br><br>
Linear transformation in 2 dimensions:
<div class="compute"><script type="text/x-sage">
L=[(1,1),(1,0),(0,0),(0,1),(1,1),(0.5,1.5),(0,1),(0,1.4),(0.25,1.4),(0.25,1.25)]
example = [[1,0],[0,1]]

@interact
def _(A=input_grid(2,2, default = example,
                   label='A=', to_value=matrix),
      auto_update=false):
    print('det(A) = ',det(A))
    LA = list(map(lambda v: vector(A*matrix(2,1,list(v))), L))
    show(line(L, color='blue'), aspect_ratio=1, frame=true, title='Input')
    show(line(LA, color='red'), aspect_ratio=1, frame=true, title='Output')
    show(line(L, color='blue')+line(LA, color='red'),
        aspect_ratio=1, frame=true, title='Both')
</script></div>

<br><br>
As above, but with a rotation matrix
\[
A = \left( \begin{array}{ll} \cos\theta & -\sin\theta \\ \sin\theta & \cos\theta
\end{array}\right)
\]
<div class="compute"><script type="text/x-sage">
L=[(1,1),(1,0),(0,0),(0,1),(1,1),(0.5,1.5),(0,1),(0,1.4),(0.25,1.4),(0.25,1.25)]
example = [[1,0],[0,1]]

@interact
def _(theta=slider(-3.14,3.14,step_size=0.01,default=pi/3),
      auto_update=false):
    A = matrix(2,2,[cos(theta), -sin(theta), sin(theta), cos(theta)])
    show('A = '+latex(A))
    print('det(A) = ',det(A))
    LA = list(map(lambda v: vector(A*matrix(2,1,list(v))), L))
    show(line(L, color='blue'), aspect_ratio=1, frame=true, title='Input')
    show(line(LA, color='red'), aspect_ratio=1, frame=true, title='Output')
    show(line(L, color='blue')+line(LA, color='red'),
        aspect_ratio=1, frame=true, title='Both')
</script></div>

<br><br>
Linear transformation in 3 dimensions. Here we plot the effect of
a linear transformation on three unit vectors and the parallelepiped spanned by them.
<div class="compute"><script type="text/x-sage">
example = [[1,0,0],[0,1,0],[0,0,1]]
L = [(0,0,1),(0,1,0),(1,0,0)]
P = polytopes.parallelotope(L)
p1 = P.plot(opacity=0.5, color='blue')+\
arrow((0,0,0),L[0], color='blue')+\
arrow((0,0,0),L[1], color='blue')+\
arrow((0,0,0),L[2], color='blue')


@interact
def _(A=input_grid(3,3, default = example,
                   label='A='),
      auto_update=false):
    A = matrix(QQ,3,3,A)
    print('det(A) = ',det(A))
    LA = list(map(lambda v: vector(A*matrix(3,1,list(v))), L))
    PA = polytopes.parallelotope(LA)
    p2 = PA.plot(opacity=0.5, color='red')+\
    arrow((0,0,0),LA[0], color='red')+\
    arrow((0,0,0),LA[1], color='red')+\
    arrow((0,0,0),LA[2], color='red')
    print('Input:')
    show(p1, aspect_ratio=1)
    print('Output:')
    show(p2, aspect_ratio=1)
    print('Both:')
    show(p1+p2, aspect_ratio=1)

</script></div>

<h1>Linear Algebra IV: Square matrices</h1>

<br><br>
Inverting a matrix using row reduction:<br><br>
<div class="compute"><script type="text/x-sage">
# Code by Hristo Inouzhe

#Choose the size D of the square matrix:
D = 3

example = [[1 if k==j else 0 for k in range(D)] for j in range(D)]
example[0][-1] = 2
example[-1][0] = 3

@interact
def _(M=input_grid(D,D, default = example,
                   label='Matrix to invert', to_value=matrix),
      tt = text_control('Enter the bits of precision used'
                        ' (only if you entered floating point numbers)'),
      precision = slider(5,100,5,20),
      auto_update=False):
    if det(M)==0:
        pretty_print('Failure: Matrix is not invertible')
        return
    if M.base_ring() == RR:
        M = M.apply_map(RealField(precision))
    N=M
    M=M.augment(identity_matrix(D))
    pretty_print('We construct the augmented matrix')
    show(M)
    for m in range(0,D-1):
        if M[m,m] == 0:
            lista = [(abs(M[j,m]),j) for j in range(m+1,D)]
            maxi, c = max(lista)
            M[c,:],M[m,:]=M[m,:],M[c,:]
            pretty_print('We permute rows %d and %d'%(m+1,c+1))
            show(M)
        for n in range(m+1,D):
            a=M[m,m]
            if M[n,m]!=0:
                pretty_print("We add %s times row %d to row %d"%(-M[n,m]/a, m+1, n+1))
                M=M.with_added_multiple_of_row(n,m,-M[n,m]/a)
                show(M)
    for m in range(D-1,-1,-1):
        for n in range(m-1,-1,-1):
            a=M[m,m]
            if M[n,m]!=0:
                pretty_print("We add %s times row %d to the row %d"%(-M[n,m]/a, m+1, n+1))
                M=M.with_added_multiple_of_row(n,m,-M[n,m]/a)
                show(M)
    for m in range(0,D):
        if M[m,m]!=1:
            pretty_print('We divide row %d by %s'%(m+1,M[m,m]))
            M = M.with_row_set_to_multiple_of_row(m,m,1/M[m,m])
            show(M)
    M=M.submatrix(0,D,D)
    pretty_print('We keep the right submatrix, which contains the inverse')
    show('M^{-1} = '+latex(M))
#     html('$$M^{-1}=%s$$'%latex(M))
    pretty_print('We check it actually is the inverse')
    show('M^{-1}\\cdot M = '+latex(M)+'\\cdot'+latex(N)+' = '+latex(M*N))
#     show('M^{-1}*M=%s*%s=%s'%(latex(M),latex(N),latex(M*N)))
</script></div>

<h1>Linear Algebra V: Eigenvectors and Eigenvalues</h1>

For a square matrix \(A\), we say that \({\bf v}\) is an <i>eigevector</i>
of \(A\) with <i>eigenvalue</i> \(\lambda\), if
$$ A{\bf v} = \lambda{\bf v}$$.
<br><br>

In this example, the blue vector is a unit vector with angle \(\theta\), i.e.
\({\bf v} = (\cos(\theta), \sin(\theta))^T\), and the red vector is \(A{\bf v}\).
When they're parallel, you've found an eigenvector.
<div class="compute"><script type="text/x-sage">
example = [[1,2],[4,3]]

@interact
def _(A=input_grid(2,2, default = example,
                   label='A=', to_value=matrix),
      theta = slider(-3.15, 3.15, step_size=0.01, default=0),
      zoom = slider(1,20, step_size=1, default=5),
      auto_update=true):

    print('Eigenvectors: ', [v for (l, v, n) in A.eigenvectors_right()])
    print('Eigenvalues: ', [l for (l, v, n) in A.eigenvectors_right()])
    v = matrix(2,1,[cos(theta), sin(theta)])
    Av = A*v
    show(
        arrow((0,0), vector(v), color='blue')+\
        arrow((0,0), vector(Av), color='red'),
        aspect_ratio=1, frame=true, xmin=-zoom, xmax=zoom, ymin=-zoom, ymax=zoom
    )
</script></div>

<h1>Linear Algebra VI: Applications of Eigenvalues and Eigenvectors</h1>

For a square matrix \(A\), let \(P\) be the matrix whose columns are the
eigenvectors of \(A\), and \(D\) the diagonal matrix whose diagonal entries
are the corresponding eigenvalues of \(A\), then we have
$$
A = PDP^{-1}.
$$
This can be useful for computing powers of \(A\), because
$$
A^n = PD^nP^{-1}
$$
and powers of a diagnoal matrix (such as \(D\)) are easy to compute.
We demonstrate this with the Fibonacci matrix:

<div class="compute"><script type="text/x-sage">
K.<a>=QuadraticField(5)
# We'll do our calculations in K so that Sagemath works with sqrt(5) exactly rather
# than approximating it with digits...
A = matrix(K,2,2,[0,1,1,1])
pretty_print('The Fibonacci matrix: ')
pretty_print('A = '+latex(A))
[(l1,[v1],n1),(l2,[v2],n2)] = A.eigenvectors_right(extend=false)
v1 = matrix(2,1,v1)  # turn v1 and v2 into 2x1 matrices
v2 = matrix(2,1,v2)
(D, P) = A.eigenmatrix_right()
pretty_print("Its eigenvalues are:")
pretty_print(r'\lambda_1 = '+latex(l1)+r',\qquad \lambda_2 = '+latex(l2))
pretty_print('With corresponding eigenvectors:')
pretty_print(r'{\bf v}_1 = '+latex(v1)+r',\qquad {\bf v}_2 = '+latex(v2))
pretty_print('We should have ',r'\; A = PDP^{-1}\;'+latex(''),'with')
pretty_print('P = '+latex(P)+r',\qquad D = '+latex(D))
pretty_print("Let's check it:")
pretty_print(r'PDP^{-1}\; =\; '+latex(P)+r'\cdot'+latex(D)+r'\cdot'+\
             latex(P.inverse())+r'\; = \;'+latex(P*D*P.inverse())+r'\; = \; A.')
pretty_print('Now powers of A are easy to compute:',r'\; A^n = PD^nP^{-1}'+latex(''))

@interact
def _(n = slider(0, 200, step_size=1, default=0)):
    pretty_print('A^{'+str(n)+'} = PD^{'+str(n)+'}P^{-1} = '+latex(P*D^n*P.inverse()))
    print()

</script></div>

<br><br>

Now Binet's Formula for the nth Fibonacci number is easily deduced by extracting
the top-right entry of \(A^n = PD^nP^{-1}\):

<div class="compute"><script type="text/x-sage">
pretty_print("Binet's Formula:  ", r'\;F_n = \frac{\phi^n - \bar{\phi}^n}{\sqrt{5}}'+latex(''))
phi = (1+sqrt(5))/2
phibar = (1-sqrt(5))/2
pretty_print(r'\phi \; = \;'+latex(phi)+r', \qquad \bar{\phi} \; = \;'+latex(phibar))
@interact
def _(n = slider(0, 200, step_size=1, default=0)):
    Fn = (phi^n-phibar^n)/sqrt(5)
    pretty_print('F_{'+str(n)+r'} = \;'+latex(round(Fn)))   # we use round(Fn) to force Sage to simplify it
</script></div>

<br><br>
You can play similar games with your own favourite matrix.
The following code is written specifically for 2x2 matrices, but in principle
this can be done with nxn matrices - so long as the matrix P of eigenvectors
is nxn and invertible (which is not always the case!).

<div class="compute"><script type="text/x-sage">
example = [[0,1],[1,1]]
@interact
def _(A=input_grid(2,2, default = example,
                   label='A =', to_value=matrix),
      n = slider(0, 200, step_size=1, default=0),
      auto_update=true):
    d = A.characteristic_polynomial().discriminant()
    if not is_square(d):
        K.<a> = QuadraticField(d.squarefree_part())
        A = matrix(K,2,2,A)
    (D, P) = A.eigenmatrix_right()
    pretty_print('We have', r'\; A = PDP^{-1}\;'+latex(''),'where')
    pretty_print(r'A \; = \; '+latex(A)+r', \qquad P \; = \;'+latex(P)+r',\qquad D \; = \;'+latex(D))
    pretty_print(r'A^{'+str(n)+r'} \;=\; PD^{'+str(n)+r'}P^{-1} \;=\; '+\
                 latex(P)+latex(D^n)+latex(P.inverse())+r'\; = \;'+latex(P*D^n*P.inverse()))

</script></div>

<h2>Your own computations</h2>
Type your own Sage computation below and click &ldquo;Evaluate&rdquo;.
<div class="compute"><script type="text/x-sage">
plot(sin(x), (x, 0, 2*pi))

</script></div>
<div class="compute"><script type="text/x-sage">
@interact
def f(n=(0,10)):
    print(2^n)
</script></div>
<br><br>
Is \(e^{\pi\sqrt{163}} \) an integer??<br><br>
<div class="compute"><script type="text/x-sage">
a=N(exp(pi*sqrt(163)),digits=30)
print(a.str(no_sci=2)[:30])
</script></div>
  </body>
</html>
